Topic 1. Основные приалинципы, методы и перспективы разработки объектно- ориентированных программ и сетевых приложений. Topic 2. Фундаментальные методы и свойства сетевой архитектуры и механизмы ее программной реализациив desktop- и web-приложениях
1.	Парадигмы программирования, используемые при создании сетевых приложений. Принципы объектно-ориентированного программирования и особенности их реализации.
Парадигмы: 
Если покопаться в сети, тогда можно найти множество определений выражению «парадигмы программирования». В разные годы разные программисты описывали это выражение своими словами. Изучив их все, можно заметить, что парадигмы, по сути, являются моделями программирования. Изучив, какие бывают основные парадигмы программирования, вы поймете, о чем речь.
Парадигма объектно-ориентированного программирования
Объектно-ориентированное программирование — это одна из самых распространенных моделей программирования. Его причисляют к другой парадигме — императивному программированию, однако правильнее говорить об ООП, потому что оно наиболее часто применяется.
Суть его сводится к тому, что в программе происходит манипуляция разными объектами. Исходя из этого, получается, что ООП преследует идеологию создания множества объектов. Каждый объект создается из другого объекта или класса, тем самым образовывая сложную иерархию.
Объектно-ориентированному программированию свойственны такие принципы, как:
 абстракция,
 инкапсуляция,
 наследование,
 полиморфизм.
Такой подход отлично реализуется в Java или С#, но также может быть реализован и в других языках в той или иной степени. ООП не объяснить в двух предложениях, поэтому мы обязательно опишем эту парадигму в отдельной статье.
Парадигма функционального программирования
Парадигма функционального программирования заняла почетное второе место по популярности после объектно-ориентированного программирования. Главная идея такой модели заключается в том, что программа создается под одну конкретную задачу, поэтому от нее ждут конкретный результат.
Программисты, которые отдельно используют ООП или ФП, часто спорят о том, какая из этих двух парадигм лучше. Но невозможно выделить лучшую, потому что выбор парадигмы зависит от требований к программе и языка, на котором она будет писаться. Язык, который был разработан для функционального программирования, — Haskell. Однако неплохо с этой парадигмой справляется Python.
В ООП основной компонент программы — объект. В функциональном программировании — функция. В функциях прописывается, какую информацию она должна получить в качестве входящего значения, а какую должна отдать. Функции могут быть вложенными — это когда одна функция является аргументом другой функции.
Программы, написанные по такой модели, обычно легче тестировать и читать, если сравнивать с ООП.
Процедурная парадигма программирования
Процедурная парадигма программирования основывается на процедурах. Процедура — это инструкция, которая используется для воздействия на состояние памяти. После исполнения всего набора инструкций программа выдает результат.
Процедурное программирование не так распространено, как первые две парадигмы, однако поддерживается в таких популярных языках, как С и Go. Такая парадигма по своей простоте схожа с функциональным программированием. Однако программы, написанные в такой модели, сложнее масштабировать.
Парадигма декларативного программирования
В такой парадигме программист описывает проблему и ожидаемый результат, но не дает инструкций программе, как достичь этого результата. В таком подходе отсутствуют переменные, состояния программы и операторы присваивания.
К примеру, если написать программу в такой парадигме, которая будет вычислять из большого массива чисел все числа, которые больше 5, но меньше 500, тогда программисту нужно будет только написать что-то подобное: «Вычислить из «myArray» числа, которые больше 5, но меньше 500». При этом программисту не нужно будет описывать инструкции, каким образом программа должна найти эти числа, то есть он просто описывает результат.
Логическая парадигма программирования
Логическое программирование является подвидом декларативного. Это достаточно редкая парадигма. В ее основе лежит использование математической логики и математических принципов, то есть информация в программе выводится на основе заданных фактов, расчетов и набора математических правил. Если упростить понимание этой парадигмы до минимума, тогда можно сказать так: программа строится по принципу «вопрос-ответ».
Такой вид программирования используется языками Prolog и Planner.




●	Инкапсуляция: Сокрытие внутреннего состояния и функций объекта и предоставление доступа только через открытый набор функций.
 
●	Наследование: Возможность создания новых абстракций на основе существующих.
 
●	Полиморфизм: Возможность реализации наследуемых свойств или методов отличающимися способами в рамках множества абстракций.
 
 

●	Абстракция
 


2.  Фундаментальные методы и свойства сетевой архитектуры и механизмы ее программной реализации в desktop- и web-приложениях
Для реализации сетевого взаимодействия используется Java.net, который предоставляет классы и интерфейсы, позволяющие реализовывать сетевое взаимодействие. В сети каждая машина однозначно характеризуется уникальным IP-адресом, который может быть описан с помощью двух разных подходов: IPv4 и IPv6, каждому из которых соответствует пакет в классе Java.net: Inet4(6)address. Необходимо указать адрес, с которым будет установлено соединение. Для этого указывается порт. Кол-во портов, которые могут быть выделены определяется протоколом взаимодействия и свободными портами, которые выделяет ОС.
Общая схема взаимодействия клиента и сервера выглядит следующим образом: сервер должен создать сокет как терминальный участок соединения. Затем могут быть выполнены дополнительные настройки, например, такие как: соединение сокета и порта, задание количества клиентов. Затем сервер должен войти в режим ожидания входящих запросов на соединение. Для того, чтобы вывести сервер из ожидающего состояние необходимо на клиентской стороне должен быть создан сокет и отправлен запрос на создание соединения. После этого клиент и сервер входят в режим взаимодействия, который сводится к созданию потоков ввода-вывода, как на клиентской, так и на серверной сторонах и к пересылке данных между клиентом и сервером. В Java тип адресации определяется автоматически.
Веб
Java EE (Enterprise Edition) представляет собой широко используемую платформу, содержащую набор взаимосвязанных технологий, которые существенно сокращают стоимость и сложность разработки, развертывания многоуровневых серверных приложений, а также управления ими. Платформа Java EE основана на платформе Java SE и предоставляет набор интерфейсов API (интерфейсов разработки приложений) для разработки и запуска портируемых, надежных, масштабируемых и безопасных серверных приложений.
Java EE в числе прочих содержит следующие компоненты:
Enterprise JavaBeans (EJB): управляемая серверная архитектура компонентов, используемая для инкапсуляции бизнес-логики приложения. Технология EJB позволяет осуществлять быструю и упрощенную разработку распределенных, транзакционных, безопасных и переносимых приложений, основанных на технологии Java.
Интерфейс API сохранения состояния Java (Java Persistence API, JPA): инфраструктура, позволяющая разработчикам управлять данными с помощью объектно-реляционного сопоставления (ORM) в приложениях, созданных на платформе Java.
Десктоп
При разработке десктопного приложения на Java выбор в принципе стоит между JavaFx и Swing. JavaFx показался дружелюбным в разработке, поэтому выбор пал на него. Swing все-таки с читается устаревшей технологией и даже Oracle говорит о замене Swing на JavaFx.
3.  Понятие о сетевой архитектуре. Особенности процесса передачи данных по сети. Работа с сетью на уровне сокетов и потоков.
Архитектура: клиент-сервер-база данных.
Особенности: данные передаются в пакетах (массив байт).
Общая схема взаимодействия клиента и сервера по любому протоколу: сервер должен создать сокет как терминальный(конечный) участок соединения, затем могут быть выполнены дополнительные настройки, например, такие как соединение сокета и порта, задание кол-ва клиентов, которые могут ожидать подключения. Затем сервер должен войти в режим ожидания создания входящих запросов на создание соединения, этот оператор обычно блокирует работу сервера. Для того чтобы вывести сервер из состояния ожидания на клиентской стороне должен быть создан сокет и отправлен запрос на создание соединения. Если соединение создано успешно, клиент и сервер переходит в режим взаимодействия, который сводится к созданию потоков ввода-вывода как на клиентской, так и серверной сторонах и к пересылке данных между клиентом и сервером. Соединение может быть закрыто как на клиентской так и на серверной стороне.
4 потока между клиентом и сервером. 2 у клиента (входной и выходной) и 2 у сервера (входной и выходной).
4.  Понятие протокола и механизмы взаимодействия в системе клиент-сервер. Обзор общих принципов построения многоуровневых приложений. Способы доступа к ресурсам сети из программных приложений при помощи URL.
Сетевой протокол — это набор правил, определяющий принципы взаимодействия устройств в сети. Чтобы отправка и получение информации прошли успешно, все устройства-участники процесса должны принимать условия протокола и следовать им
Механизм взаимодействия:
1. Сервер подключается к порту на хосте и ждет соединения с клиентом
2. Клиент создает сокет и пытается соединить его с портом на хосте
3. При соединении клиента сервер получает свой сокет для взаимодействия с клиентом и переходит в режим ожидания команд от клиента
4. Клиент формирует команду и передает ее через сокет серверу, переходит в режим ожидания ответа
5. Сервер принимает команду через сокет, выполняет ее и пересылает ответ клиенту.
Принципы построения: эффективность системы (производительность), гибкость системы (изменяемость), расширяемость системы, тестируемость.
Класс URL(uniform resource located) предназначен для однозначной идентификации ресурсов сети интернет. URI(uniform resource identifier) включает обязательно весь путь к ресурсу: протокол, доменное имя, весь путь прохождения по папками имя самого ресурса.


Topic 2. Язык Java. Обзор базовых конструкций и элементов языка
5.  Типы данных, переменные, массивы. Символы. Логические значения
Типы данных:
Одной из основных особенностей Java является то, что данный язык является строго типизированным.
boolean: хранит значение true или false – 1 байт
byte: хранит целое число от -128 до 127 и занимает 1 байт
short: хранит целое число от -32768 до 32767 и занимает 2 байта
int: хранит целое число и занимает 4 байта
long: хранит целое число и занимает 8 байт
double: хранит число с плавающей точкой и занимает 8 байт
float: хранит число с плавающей точкой и занимает 4 байта
char: хранит одиночный символ и занимает 2 байта, поэтому диапазон хранимых значений от 0 до 65535
Массивы:
Массив представляет набор однотипных значений. Объявить массив можно так:
тип_данных название_массива[]; 	либо
тип_данных[] название_массива;
Инициализация массива: new тип_данных[количество_элементов]
Также можно сразу задать значения массива, например:
int arr[] = new int[] {1,2,3,4,5};
.lenght – возвращает длину массива
.clone() – вернёт копию массива
Символы:
Символы в Java представлены типом char. Символ можно задать как:
char a = ‘a’    	char a = 102 (Unicode)          	char a = ‘\u0066’ – 16-ичная форма      	
Также есть специальные символы, называемые управляющей последовательностью:
\t	Символ табуляции.
\b	Символ возврата в тексте на один шаг назад или удаление одного символа в строке (backspace).
\n	Символ перехода на новую строку.
\r	Символ возврата каретки.
\f	Прогон страницы.
\'	Символ одинарной кавычки.
\"	Символ двойной кавычки.
\\	Символ обратной косой черты (\).
 
Логические выражения:
<, > , <=, >=, ==, !=, &, &&, |, ||, ^, !

 
6.  Целые числа. Тип byte. Тип short. Тип long. Тип int. Числа с плавающей точкой. Тип double. Тип float.

byte: хранит целое число от -128 до 127 и занимает 1 байт

short: хранит целое число от -32768 до 32767 и занимает 2 байта

int: хранит целое число и занимает 4 байта

long: хранит целое число и занимает 8 байт

double: хранит число с плавающей точкой и занимает 8 байт

float: хранит число с плавающей точкой и занимает 4 байта

 L – литерал типа Long

0xЧисло – 16-ичная форма

0101536 – 8-ичная форма

0b01011001 – 2-ичная форма

f -литерал float


7.  Переменные в Java. Область и время действия переменных. Именование переменных

это контейнер, в котором может храниться некоторое значение данных для дальнейшего использования в программе.
Область видимости переменной начинается с момента объявления и уничтожается после выхода из ее области видимости
Все переменные и методы в Java всегда именуются только используя так называемую нижнююВерблюжьюНотацию или lowerCamelCase

Для хранения данных в программе предназначены переменные. Переменная представляет именованную область памяти, которая хранит значение определенного типа. Каждая переменная имеет тип, имя и значение. Тип определяет, какую информацию может хранить переменная.
Переменные объявляются следующим образом:
тип_данных имя_переменной;
Правила именования переменных:
-         имя может содержать любые алфавитно-цифровые символы, а также знак подчеркивания, при этом первый символ в имени не должен быть цифрой
-         в имени не должно быть знаков пунктуации и пробелов
-         имя не может быть ключевым словом языка Java
Также переменные можно создавать с помощью var – java исходя из литерала сама присвоит типа данных.
final – константы
В программировании принято называть переменные по принципу lowerCamelCase
Переменные в java имеют область видимости в пределах блока {} в котором они находятся. Когда переменная полностью выходит из области видимости, она удаляется. 


Область действия и время жизни переменных
Java позволяет объявлять переменные в любом блоке. Блок определяет область. Таким образом, каждый раз, когда вы начинаете новый блок, вы создаете новую область. Область действия определяет, какие объекты видны другим частям вашей программы. Это также определяет время жизни этих объектов.


В Java существует три вида переменных, основанных на области действия и времени жизни.

Локальная переменная: Локальные переменные объявляются в методах, конструкторах или блоках.

Глобальная переменная / переменная экземпляра: переменные экземпляра объявляются в классе, но вне метода, конструктора или любого блока.
Переменная экземпляра также является переменной объекта, обычно называемой полем или свойством. Они называются объектной переменной. Каждый объект имеет свою собственную копию каждой переменной, и, следовательно, он не влияет на переменную экземпляра, если один объект изменяет значение переменной.

Класс / Статические переменные: переменные класса, также известные как статические переменные, объявляются с ключевым словом static в классе. 
Внутри блока переменные могут быть объявлены в любой точке, но они действительны только после их объявления. Если вы определяете переменную в начале метода, она доступна для всего кода в этом методе.
Переменные создаются при вводе их области действия и уничтожаются при оставлении их области действия.
Переменная не будет сохранять свое значение после выхода из области видимости.
Переменные, объявленные в методе, не будут хранить свои значения между вызовами этого метода. Кроме того, переменная, объявленная в блоке, потеряет свое значение при выходе из блока. Таким образом, время жизни переменной ограничено ее областью действия.
Если объявление переменной включает инициализатор, то эта переменная будет повторно инициализироваться каждый
время вводится блок, в котором он объявлен.


8.  Преобразование и приведение типов. Автоматическое продвижение типов в выражениях. Правила продвижения типов.

Явные и неявные преобразования:
явные: в преобразованиях примитивных типов явным образом применяется операция преобразования типов. Обычно это сужающие преобразования (narrowing) от типа с большей разрядностью к типу с меньшей разрядностью ex: long -> int
 
неявные: выполняются автоматически ex: int -> float, long -> float и long -> double.
 

- Правила продвижения типов: (ex: если один операнд имеет тип double, то и второй операнд продвигается к типу double. и так же с float и long и др.) 
но не все типы могут смешиваться в выражении и если ни одно из предыдущих правил не применяется, то все операнды продвигаются к типу int
 

9.  Операции. Логические операции. Предшествование операций. Тернарный оператор ?
●	! — оператор отрицания;
●	&& — оператор логическое И (сокращенный);
●	|| — оператор логическое ИЛИ (сокращенный);
●	& — оператор побитовое И;
●	| — оператор побитовое ИЛИ;
●	^ — оператор побитовое исключающее ИЛИ.
операции в скобках выполняются раньше всех а за тем:
●	++, - - (постинкремент, постдекремент)
●	++, - - , +, - (преинкремент, предекремент, унарный плюс, унарный минус)
●	*, /, % ( умножение, деление, остаток от деления)
●	+, — ( сложение, вычитание)
●	<, >, <=, >=
●	==, !=
●	&&
●	||
●	 ?:  (тернарный оператор)
●	 =, +=, -=,*=, /=, %= (операторы присваивания)
Тернарная операция
Тернарную операция имеет следующий синтаксис: [первый операнд - условие] ? [второй операнд] : [третий операнд]. Таким образом, в этой операции участвуют сразу три операнда. В зависимости от условия тернарная операция возвращает второй или третий операнд: если условие равно true, то возвращается второй операнд; если условие равно false, то третий.
int x=3;
int y=2;
int z = x<y? (x+y) : (x-y);
10.  Управляющие операторы. Операторы цикла Операторы перехода. Оператор return

Управляющие операторы разделяются на три категории: операторы выбора, к числу которых относятся операторы if и switch, итерационные операторы, в том числе операторы цикла for, while, dowhile и foreach, а также операторы перехода: break, continue, return и throw.
Switch:
int month = 8;
        String monthString;
        switch (month) { // switch можно вкладывать один в другой (как и if)
            case 1:  monthString = "January";
                     break; // необходим чтобы выполнение не продолжилось
// но при этом  break не является обязательным в  switch
            case 2:  monthString = "February";
                     break;
            case 3:  monthString = "March";
                     break;
            case 4:  monthString = "April";
Foreach:
int[] grades
for (int num : grades) {

            System.out.print(num + "|");
        }
For. Do. While
Операторы цикла:
for (инициализация; условие; итерация) {
  последовательность операторов;
}
do {
  операторы;
} while (условие);
Break. Continue.
Операторы перехода:
for (int i = -10; i <= 10; i++) {
  	if (i > 0)
    	break;  // завершить цикл,  как только значение переменной i станет положительным
  	Console.Write(i + " ");
	}
for (int i = 0; i <= 100; i++) {
  	if ((i % 2) != 0)  // % возвращает остаток от деления
    	continue;  // перейти к следующему шагу итерации
  	Console.WriteLine(i);
	}
Оператор Return. Оператор return используют для выполнения явного выхода из метода. Оператор можно использовать в любом месте метода для возврата управления тому объекту, который вызвал данный метод. Таким образом, return прекращает выполнение метода, в котором он находится.
У return есть две формы:
1.	Немедленно заканчивает выполнение метода.
2.	Немедленно заканчивает выполнение метода и возвращает какое-то значение в качестве результата работы метода.
return;
return value; // где value — некоторое возвращаемое значение

11.  Применение оператора instanceof. Комментарии в Java. Одномерные массивы. Сортировка элементов массива
instanceof нужен для того, чтобы проверить, какой тип у объекта. Пример:
public class Main {
   public static void main(String[] args) {
   	Integer x = new Integer(22);
   	System.out.println(x instanceof Integer); /* выведет на экран true, так как переменная x имеет тип Integer*/
   }}
Писать комментарии можно через:
// -- и далее текст комментария.
/* какой-то текст, может быть многострочным */
Одномерные массивы. Пример –
int[] arrOfVirgins
 Как видите, массив пустой. Можно ещё так
int arrOfVirgins[] = new int[5]
создаст массив размером 5.
int arrOfVirgins = new int[] { 1, 2, 3, 4 }
 – заполненный массив с 4 элементами.
Сортировка. Для сортировки юзаем java.util.Arrays.sort(). Для сортировки элементы массива должны быть comparable. Если в массиве, к примеру, есть и Int, и String (да блять, такое возможно), то вместо отсортированного массива ты получишь ХУЙ, ибо нехуй сравнивать числа со строками.
Если в массиве хранятся классы то можно сортировать их по разным полям с помощью конструкции:
a.sort(Comparator.comparing(Student::getName));
12.  Многомерные массивы. Двумерные массивы. Нерегулярные (непрямоугольные, зубчатые) массивы
Массив, элементами которого являются другие массивы, то есть массив массивов, называется двумерным.
В обобщённом виде многомерные массивы в Java выглядят так:
Data_type[dimension1][dimension2][]..[dimensionN] array_name = new data_type[size1][size2]….[sizeN];
Где Data_type — это тип элементов в массиве. Может быть примитивным или ссылочным (классом).
Количество пар скобок с dimension внутри — размерность массива (в нашем случае — N).
array_name —  название массива 
size1...sizN — количество элементов в каждом из измерений массива.
Объявление многомерных массивов:
int[][] twoDimArray; //двумерный массив
String[][][] threeDimArray; //трёхмерный массив
double[][][][][] fiveDimArray; // пятимерный массив
Двумерный массив в Java — это массив массивов, то есть в каждой его ячейке находится ссылка на некий массив. Но гораздо проще его представить в виде таблицы, у которой задано количество строк (первое измерение) и количество столбцов (второе измерение). Двумерный массив, у которого все строки имеют равное количество элементов, называется прямоугольным. 
int[][] twoDimArray = new int[3][4]; // Этот массив имеет 3 строки и 4 столбца
int [][] twoDimArray = {{5,7,3,17}, {7,0,1,12}, {8,1,2,3}}; 
Вывод двумерного массива:
int[][] myArray = {{18,28,18},{28,45,90},{45,3,14}};
System.out.printLn(Arrays.deepToString(myArray));
Нерегулярные массивы – это разновидность n-мерных (n>1) массивов, которые представлены как массивы одномерных массивов с разным количеством элементов.
// объявление регулярных и нерегулярных массивов
int[][] A = new int[3][5]; // регулярный массив
int[][] B = new int[3][]; // нерегулярный двумерный массив
int[][][] C = new int[3][4][]; // нерегулярный трехмерный массив
int[][][] D = new int[3][][]; // нерегулярный трехмерный массив
// int[][][] E = new int[][][]; // ошибка, так нельзя объявлять массив


int[][] A = new int[3][5]; // регулярный массив, количество элементов = 3*5 = 15
int[][] B = new int[3][]; // нерегулярный массив, общее количество элементов неизвестно

Массив B содержит 3 одномерных массива. Количество элементов в любом из этих массивов неизвестно.
// выделение памяти для массива B
for (int i=0; i<3; i++)
  B[i] = new int [i*2+1];

// заполнение массива B значениями
for (int i=0; i<3; i++)
  for (int j=0; j<B[i].length; j++)
    B[i][j] = i*3+j;

Зубчатый массив
 // Объявить зубчатый массив, содержащий три элемента
        int[][] arr = new int[3][];
 
        // Инициализируем элементы
        arr[0] = new int[] { 1, 2, 3 };
        arr[1] = new int[] { 4, 5, 6, 7 };
        arr[2] = new int[] { 8, 9 };
 
        // печатаем элементы массива
        for (int[] row: arr) {
            System.out.println(Arrays.toString(row));



13.  Трехмерные, четырехмерные, многомерные массивы. Инициализация многомерных массивов
Наиболее известный многомерный массив - таблица, представляющая двухмерный массив:
int[] nums1 = new int[] { 0, 1, 2, 3, 4, 5 };
int[][] nums2 = { { 0, 1, 2 }, { 3, 4, 5 } };
Поскольку массив nums2 двухмерный, он представляет собой простую таблицу. Его также можно было создать следующим образом:
 int[][] nums2 = new int[2][3];. 
Количество квадратных скобок указывает на размерность массива. А числа в скобках - на количество строк и столбцов. И также, используя индексы, мы можем использовать элементы массива в программе:
nums2[1][0]=44;
System.out.println(nums2[1][0]);
Объявление трехмерного массива могло бы выглядеть так:
int[][][] nums3 = new int[2][3][4];

14.  Применение переменной экземпляра length. Класс Arrays

Важнейшее свойство, которым обладают массивы, является свойство length, возвращающее длину массива, то есть количество его элементов:

int[] nums = {1, 2, 3, 4, 5};
int length = nums.length;   // 5

Нередко бывает неизвестным последний индекс, и чтобы получить последний элемент массива, мы можем использовать это свойство:

int last = nums[nums.length-1];

Решать типовые задачи при работе с массивами тебе поможет специальный класс Java — Arrays.

Сортировка массива
int[] numbers = {167, -2, 16, 99, 26, 92, 43, -234, 35, 80};
Arrays.sort(numbers);

Преобразование массива в строку
Arrays.toString()

Копирование массива
int[] numbers = {167, -2, 16, 99, 26, 92, 43, -234, 35, 80};
int [] numbersCopy = Arrays.copyOf(numbers, 4);

15.  Разновидность for-each цикла for. Циклическое обращение к элементам многомерных массивов. Использование расширенного цикла for

Специальная версия цикла for предназначена для перебора элементов в наборах элементов, например, в массивах и коллекциях. Она аналогична действию цикла foreach , который имеется в других языках программирования. Формальное ее объявление:
for (тип_данных название_переменной : контейнер){
    // действия
}

Например:
int[] array = new int[] { 1, 2, 3, 4, 5 };
for (int i : array){
             
    System.out.println(i);
}

В качестве контейнера в данном случае выступает массив данных типа int. Затем объявляется переменная с типом int

То же самое можно было бы сделать и с помощью обычной версии for:

int[] array = new int[] { 1, 2, 3, 4, 5 };
for (int i = 0; i < array.length; i++){
    System.out.println(array[i]);
}

В то же время эта версия цикла for более гибкая по сравнению for (int i : array). В частности, в этой версии мы можем изменять элементы:

int[] array = new int[] { 1, 2, 3, 4, 5 };
for (int i=0; i<array.length;i++){
    array[i] = array[i] * 2;
    System.out.println(array[i]);
}
 
Обращение к элементам многомерных массивов
int [][] twoDimArray = {{5,7,3,17}, {7,0,1,12}, {8,1,2,3}};//объявили массив и заполнили его элементами
for (int i = 0; i < 3; i++) {  //идём по строкам
            for (int j = 0; j < 4; j++) {//идём по столбцам
                System.out.print(" " + twoDimArray[i][j] + " "); //вывод элемента
            }
            System.out.println();//перенос строки ради визуального сохранения табличной формы
        }

В расширенном цикле for происходит последовательный перебор всех элементов коллекции или массива. Количество итераций цикла равна количеству элементов в коллекции или массиве. На каждой итерации значение элемента массива помещается в итерационную переменную variable, которую можно обрабатывать или использовать. Цикл гарантирует прохождение всей коллекции (массива) от первого элемента до последнего.
16.  Использование строк. Создание строк. Массивы строк. Неизменяемость строк. Класс String
Для работы со строками в Java определен класс String, который предоставляет ряд методов для манипуляции строками. Физически объект String представляет собой ссылку на область в памяти, в которой размещены символы.
Для создания новой строки мы можем использовать один из конструкторов класса String, либо напрямую присвоить строку в двойных кавычках:
String str1 = "Java";
String str2 = new String(); // пустая строка
 String str3 = new String(new char[] {'h', 'e', 'l', 'l', 'o'}); 
Поскольку строка рассматривается как набор символов, то мы можем применить метод length() для нахождения длины строки или длины набора символов:
При работе со строками важно понимать, что объект String является неизменяемым (immutable). То есть при любых операциях над строкой, которые изменяют эту строку, фактически будет создаваться новая строка.
String str1 = "Java";
System.out.println(str1.length()); // 4
А с помощью метода toCharArray() можно обратно преобразовать строку в массив символов:
String str1 = new String(new char[] {'h', 'e', 'l', 'l', 'o'});
char[] helloArray = str1.toCharArray();
Строка может быть пустой. Для этого ей можно присвоить пустые кавычки или удалить из стоки все символы:
String s = "";   // пустая строка
if(s.length() == 0) System.out.println("String is empty");
В этом случае длина строки, возвращаемая методом length(), равна 0.
Класс String имеет специальный метод, который позволяет проверить строку на пустоту - isEmpty(). Если строка пуста, он возвращает true:
String s = "";   // пустая строка
if(s.isEmpty()) System.out.println("String is empty");
Переменная String может не указывать на какой-либо объект и иметь значение null:
String s = null;   // строка не указывает на объект
if(s == null) System.out.println("String is null");

Массив строк 
String[] arrayName;
arrayName = new String[size];

// объявление двумерного массива строк
String[][] matr = new String[2][3];
// заполнение массива значениями
for (int i=0; i<matrS.length; i++)
    for (int j=0; j<matrS[i].length; j++)
        matrS[i][j] = "matrS[" + i + "][" + j + "]";
// проверка
String s;
s = matrS[0][0]; // s = "matrS[0][0]"
s = matrS[1][1]; // s = "matrS[1][1]"

Основные операции со строками раскрывается через методы класса String, среди которых можно выделить следующие:
concat, valueOf, join, compareTo, charAt, getChars, equals, indexOf, regionMatches, equalsIgnoreCase, startsWith, endsWith, replace, trim, toUpperCase

17.  Использование строк в операторе switch. Метод toString(). Использование аргументов командной строки

Строки в switch
 private static void printColorUsingSwitch(String color) {
        switch (color) {
        case "blue":
            System.out.println("BLUE");
            break;
        case "red":
            System.out.println("RED");
            break;
        default:
            System.out.println("INVALID COLOR CODE");
        }
    }


Метод toString служит для получения представления данного объекта в виде строки. 
public String toString() {
        return "Person{"
                + "fullName='" + fullName + '\''
                + ", age=" + age
                + ", retired=" + retired
                + '}';
    }
public class PersonDemo4 {
    public static void main(String[] args) {
        Person person = new Person("Петров Иван Иванович", 56, false);
        System.out.println(person);
    }
Результат:
Person{fullName='Петров Иван Иванович', age=56, retired=false}

Аргументы командной строки Java — это способ ввода данных в программу через командную строку. Все переданные через неё аргументы будут преобразованы в массив args[] внутри JVM. Аргументы командной строки передаются при выполнении команды запуска сразу после имени файла и разделяются пробелами. Аргументы командной строки принимаются массивом строк ( args[] ) в основной функции. Мы можем получить доступ к аргументам командной строки или изменить их, используя args[i] и операторы присваивания.
Аргументы класса {
    public static void main( String[] args ) {
        System.out.println("Привет, мир!");
        // args.length используется для получения длины массива args

        System.out.println(" Общее количество аргументов: " + args.length);
        // итерация по массиву args для вывода аргументов, если они доступны

        for (int i = 0; i < args.length; i++) {
            System.out.println("Аргумент" + i + ": " + args[i]);
        }
    }

Вывод
Привет мир!
 Общее количество аргументов: 7
 Аргумент 0: Добро пожаловать
 Аргумент 1: в
 Аргумент 2: это
 Аргумент 3: блог
 Аргумент 4: и
 Аргумент 5: Счастливый
 Аргумент 6: Обучение
18.  Потоки ввода-вывода. Потоки ввода-вывода байтов и символов. Классы потоков ввода- вывода байтов. Классы потоков ввода-вывода символов
Поток - это абстрактное значение источника или приёмника данных, которые способны обрабатывать информацию.
Байты.
В основе всех классов, управляющих потоками байтов, находятся два абстрактных класса: InputStream (представляющий потоки ввода) и OutputStream (представляющий потоки вывода)(байты).
InputStream:
int available(): возвращает количество байтов, доступных для чтения в потоке
void close(): закрывает поток
int read(): возвращает целочисленное представление следующего байта в потоке. Когда в потоке не останется доступных для чтения байтов, данный метод возвратит число -1
long skip(long number): пропускает в потоке при чтении некоторое количество байт, которое равно number
OutputStream:
void close(): закрывает поток
void flush(): очищает буфер вывода, записывая все его содержимое
void write(int b): записывает в выходной поток один байт, который представлен целочисленным параметром b
Класс BufferedOutputStream не сильно отличается от класса OutputStream, за исключением дополнительного метода flush(), используемого для обеспечения записи данных в буферизируемый поток. Буферы вывода нужно для повышения производительности.
import java.io.*;
public class FileCopy {
   public static void main(String args[]) throws IOException {  
      FileInputStream fileIn = null;
      FileOutputStream fileOut = null;
      try {
         fileIn = new FileInputStream("file.txt");
         fileOut = new FileOutputStream("copied_file.txt");
         int a;
	// Копирование содержимого файла file.txt
         while ((a = fileIn.read()) != -1) {
            fileOut.write(a); // Чтение содержимого файла file.txt и запись в файл copied_file.txt
         }
      }finally {
         if (fileIn != null) {
            fileIn.close();
         }
         if (fileOut != null) {
            fileOut.close();
}
 
Символьные.
Но поскольку работать с байтами не очень удобно, то для работы с потоками символов были добавлены абстрактные классы Reader (для чтения потоков символов) и Writer (для записи потоков символов).
Writer
Writer append(char c) - добавляет символ в конец вызывающего выходного потока. Возвращает ссылку на вызывающий поток
abstract void close() - закрывает вызывающий поток
abstract void flush() - финализирует выходное состояние так, что все буферы очищаются
void write(int oneChar) - записывает единственный символ в вызывающий выходной поток. Есть и другие перегруженные версии метода
Reader
abstract void close() - закрывает входной поток. Последующие попытки чтения передадут исключение IOException
void mark(int readLimit) - помещает метку в текущую позицию во входном потоке
boolean markSupported() - возвращает true, если поток поддерживает методы mark() и reset()
int read() - возвращает целочисленное представление следующего доступного символа вызывающего входного потока. При достижении конца файла возвращает значение -1. Есть и другие перегруженные версии метода
void reset() - сбрасывает указатель ввода в ранее установленную позицию метки
logn skip(long charCount) - пропускает указанное число символов ввода, возвращая количество действительно пропущенных символов
import java.io.*;
public class FileCopy {
 
   public static void main(String args[]) throws IOException {
      FileReader fileIn = null;
      FileWriter fileOut = null;
 
      try {
         fileIn = new FileReader("file.txt");
         fileOut = new FileWriter("copied_file.txt");
 
         int a;
         while ((a = fileIn.read()) != -1) {
            fileOut.write(a);
         }
      } finally {
         if (fileIn != null) {
            fileIn.close();
         }
         if (fileOut != null) {
            fileOut.close();
         }
      }
   }
} 

19.  Предопределенные потоки ввода-вывода. Чтение данных, вводимых с консоли. Буферизированный ввод данных.
Класс System содержит три переменные предопределенных потоков ввода вывода: in, out и err. Эти переменные объявлены в классе System как public, static и final.
Объект System.out называют потоком стандартного вывода. По умолчанию с ним связана консоль.
На объект System.in ссылаются как на стандартный ввод, который по умолчанию связан с клавиатурой.
К объекту System.err обращаются как к стандартному потоку ошибок, который по умолчанию также связан с консолью.

Однако эти потоки могут быть переназначены на любое совместимое устройство ввода/вывода. System, in — это объект типа InputStream; System.out и System.err — объекты типа Printstream. Это байтовые потоки, хотя они обычно используются, чтобы читать и записывать символы с консоли и на консоль. Однако их можно упаковать в символьные потоки, если нужно. Буферизация ввода - данные сначала попадают в некий буфер (текстовый файл), а в переменных они оказываются только после очистки буфера, которая происходит при определенном событии, например, нажатии “Enter”. Отсутствие буферизации – данные, введенные с клавиатуры, оказываются в переменных сразу.

20.  Ввод данных с использованием класса Scanner. Чтение символов. Чтение символьных строк. Вывод данных на консоль. Класс PrintWriter.
Чтобы считать с клавиатуры строку, нужна команда:
Scanner console = new Scanner(System.in);
String str = console.nextLine();
Когда программа дойдет до выполнения этой строки, она приостановится и будет ждать, пока пользователь введет данные и нажмет клавишу enter. После этого все, что ввел пользователь, будет сохранено в переменную str.
Методы класса Scanner
nextByte() Считывает данные и преобразует их в тип byte
nextShort() Считывает данные и преобразует их в тип short
nextInt() Считывает данные и преобразует их в тип int
nextLong() Считывает данные и преобразует их в тип long
nextFloat() Считывает данные и преобразует их в тип float
nextDouble() Считывает данные и преобразует их в тип double
nextBoolean() Считывает данные и преобразует их в тип boolean
Методы для считывания строк
next() Считывает одно «слово». Слова разделяются пробелами или enter
nextLine() Считывает целую строку
PrintWriter — это один из классов, основанных на символах. Применение такого класса для консольного вывода упрощает интернационализацию ваших программ.
PrintWriter определяет несколько конструкторов. Один из тех, которые мы будем использовать, показан ниже:
PrintWriter(OutputStream OutputStream, boolean flushOnNewline)
Здесь OutputStream — объект типа OutputStream, a flushOnNewline управляет тем, будет ли Java сбрасывать буфер в выходной поток каждый раз при вызове метода println ().
Для вывода данных на консоль используется System.out.println().
21.  Интерфейсы Autocloseable, Closeable, Flushable. Исключения ввода-вывода. Класс Inputstream. Класс OutputStream. ByteArrayInputstream
●	Autocloseable закрывает этот ресурс, отказываясь от всех под-ресурсов. Этот метод вызывается автоматически для объектов, управляемых оператором try-with-resources.
●	Сloseable закрывает этот поток и освобождает все связанные с ним системные ресурсы. Если поток уже закрыт, вызов этого метода не имеет никакого эффекта.
●	Flushable — это место назначения данных, которые можно сбросить. Метод flush вызывается для записи любого буферизованного вывода в базовый поток.
он сбрасывает этот поток, записывая любой буферизованный вывод в базовый поток.
●	ByteArrayInputStream содержит внутренний буфер, содержащий байты, которые могут быть прочитаны из потока. Внутренний счетчик отслеживает следующий байт, который будет предоставлен методом чтения.
Закрытие ByteArrayInputStream не имеет никакого эффекта. Методы этого класса можно вызывать после закрытия потока без создания исключения IOException.
●	Inputstream - этот абстрактный класс является супер-классом всех классов, представляющих входной поток байтов.
Приложения, которым необходимо определить подкласс InputStream, всегда должны предоставлять метод, возвращающий следующий байт ввода.
●	OutputStream - этот абстрактный класс является супер-классом всех классов, представляющих выходной поток байтов. Выходной поток принимает выходные байты и отправляет их в некоторый приемник.
Приложения, которым необходимо определить подкласс OutputStream, всегда должны предоставлять по крайней мере метод, записывающий один байт вывода.
try (InputStream stream = System.in;
Scanner console = new Scanner(stream)){
String line = console.nextLine();
try (OutputStream output = connection.getOutputStream();
PrintStream sender = new PrintStream(output))
{
sender.println("Привет");

22.  Класс ByteArrayOutputstream. Фильтруемые потоки ввода-вывода байтов. Буферизованные потоки ввода-вывода байтов
Класс ByteArrayOutputStream представляет поток вывода, использующий массив байтов в качестве места вывода.
Чтобы создать объект данного класса, мы можем использовать один из его конструкторов:
ByteArrayOutputStream()
ByteArrayOutputStream(int size)
Первая версия создает массив для хранения байтов длиной в 32 байта, а вторая версия создает массив длиной size.
Как и в других потоках вывода в классе ByteArrayOutputStream определен метод write, который записывает в поток некоторые данные. В данном случае мы записываем в поток массив байтов. Этот массив байтов записывается в объекте ByteArrayOutputStream в защищенное поле buf, которое представляет также массив байтов (protected byte[] buf).
Фильтрующие потоки Filtered представляют собой абстрактные классы байтовых
потоков, в которых с читаемыми байтами выполняются некоторые операции-фильтры. Объект FilterInputStream получает ввод от другого объекта InputStream, некоторым образом обрабатывает (фильтрует) байты и возвращает результат. Фильтрующие потоки могут объединяться в последовательности, при этом несколько фильтров превращаются в один сквозной фильтр. Аналогичным образом осуществляется и фильтрация вывода – для этого применяются различные классы FilterOutputStream.
Для оптимизации операций ввода-вывода используются буферизуемые потоки. Эти потоки добавляют к стандартным специальный буфер в памяти, с помощью которого повышается производительность при чтении и записи потоков.
Класс BufferedInputStream накапливает вводимые данные в специальном буфере без постоянного обращения к устройству ввода. Класс BufferedInputStream определяет два конструктора:
BufferedInputStream(InputStream inputStream, int bufSize)
Класс BufferedOutputStream аналогично создает буфер для потоков вывода. Этот буфер накапливает выводимые байты без постоянного обращения к устройству. И когда буфер заполнен, производится запись данных.
BufferedOutputStream определяет два конструктора:
BufferedOutputStream(OutputStream outputStream)
BufferedOutputStream(OutputStream outputStream, int bufSize)
public class Program {
    public static void main(String[] args) {
    	ByteArrayOutputStream baos = new ByteArrayOutputStream();
    	String text = "Hello Wolrd!";
    	byte[] buffer = text.getBytes();
    	try{
        	baos.write(buffer);
    	}
    	catch(Exception ex){
            System.out.println(ex.getMessage());
    	}
    	// превращаем массив байтов в строку
    	System.out.println(baos.toString());
    	// получаем массив байтов и выводим по символьно
    	byte[] array = baos.toByteArray();
    	for(byte b: array){
        	System.out.print((char)b);
    	}
    	System.out.println();
    }
}
23.  Класс BufferedInputStream. Класс BufferedOutputStream.
●	BufferedInputStream добавляет функциональность другому входному потоку, а именно возможность буферизации ввода и поддержку методов пометки и сброса. При создании BufferedInputStream создается массив внутренних буферов. Когда байты из потока считываются или пропускаются, внутренний буфер по мере необходимости пополняется из содержащегося в нем входного потока, по несколько байтов за раз. Операция пометки запоминает точку во входном потоке, а операция сброса вызывает повторное чтение всех байтов, прочитанных с момента самой последней операции пометки, прежде чем из содержащегося входного потока будут взяты новые байты.
●	BufferedOutputStream Класс реализует буферизованный поток вывода. Настроив такой поток вывода, приложение может записывать байты в базовый поток вывода, не обязательно вызывая вызов базовой системы для каждого записанного байта.
24.  Класс PushbackInputStream. Класс SequenceInputStream
●	PushbackInputStream добавляет функциональность к другому входному потоку, а именно возможность "отталкивать" или "непрочитанные" байты, сохраняя отталкиваемые байты во внутреннем буфере. Это полезно в ситуациях, когда фрагменту кода удобно читать неопределенное количество байтов данных, разделенных определенным значением байта; после чтения завершающего байта фрагмент кода может «непрочитать» его, так что следующая операция чтения во входном потоке будет перечитывать байт, который был вытеснен назад. Например, байты, представляющие символы, составляющие идентификатор, могут заканчиваться байтом, представляющим символ оператора; метод, задачей которого является чтение только идентификатора, может читать до тех пор, пока не увидит оператор, а затем отправляет оператор обратно для повторного чтения.
●	SequenceInputStream представляет логическое объединение других входных потоков. Он начинается с упорядоченного набора входных потоков и читает из первого до тех пор, пока не будет достигнут конец файла, после чего он читает из второго и так далее, пока не будет достигнут конец файла в последнем из содержащихся входных потоков.
25.  Класс ArrayList. Получение массива из коллекции типа ArrayList. Класс LinkedList. Различия между ArrayList и LinkedList
	Класс ArrayList представляет обобщенную коллекцию, которая наследует свою функциональность от класса AbstractList и применяет интерфейс List. Проще говоря, ArrayList представляет простой список, аналогичный массиву, за тем исключением, что количество элементов в нем не фиксировано. ArrayList имеет следующие конструкторы: 
●	ArrayList();
●	ArrayList(Collection <? extends E> col);
●	ArrayList (int capacity)
Емкость в ArrayList представляет размер массива, который будет использоваться для хранения объектов. При добавлении элементов фактически происходит перераспределение памяти - создание нового массива и копирование в него элементов из старого массива. Изначальное задание емкости ArrayList позволяет снизить подобные перераспределения памяти, тем самым повышая производительность.
С помощью метода toArray() мы можем преобразовать список в массив объектов. И поскольку класс ArrayList реализует интерфейс Iterable, то мы можем пробежаться по списку в цикле аля for-each: for(String person : people).
Хотя мы можем свободно добавлять в объект ArrayList дополнительные объекты, в отличие от массива, однако в реальности ArrayList использует для хранения объектов опять же массив. По умолчанию данный массив предназначен для 10 объектов. Если в процессе программы добавляется гораздо больше, то создается новый массив, который может вместить в себя все количество. Подобные перераспределения памяти уменьшают производительность. Поэтому если мы точно знаем, что у нас список не будет содержать больше определенного количества элементов, например, 25, то мы можем сразу же явным образом установить это количество, либо в конструкторе: ArrayList<String> people = new ArrayList<String>(25);, либо с помощью метода ensureCapacity: people.ensureCapacity(25);
	Обобщенный класс LinkedList<E> представляет структуру данных в виде связанного списка. Он наследуется от класса AbstractSequentialList и реализует интерфейсы List, Dequeue и Queue. То есть он соединяет функциональность работы со списком и функциональность очереди.
Класс LinkedList имеет следующие конструкторы:
●	LinkedList();
●	LinkedList(Collection<? extends E> col)
LinkedList содержит все те методы, которые определены в интерфейсах List, Queue, Deque. Некоторые из них:
●	addFirst() / offerFirst(): добавляет элемент в начало списка
●	addLast() / offerLast(): добавляет элемент в конец списка
●	removeFirst() / pollFirst(): удаляет первый элемент из начала списка
●	removeLast() / pollLast(): удаляет последний элемент из конца списка
●	getFirst() / peekFirst(): получает первый элемент
●	getLast() / peekLast(): получает последний элемент
ArrayList - это список на основе массива. LinkedList - связанный список на основе элементов и связи между ними. В качестве LinkedList лучше всего подходит представление вагонов поезда сцепленных последовательно.
ArrayList следует использовать, когда в приоритете доступ по индексу, так как эти операции выполняются за константное время. Добавление в конец списка в среднем тоже выполняется за константное время. Кроме того в ArrayList нет дополнительных расходов на хранение связки между элементами. Минусы в скорости вставки/удаления элементов находящихся не в конце списка, так как при этой операции все элементы правее добавляемого/удаляемого сдвигаются.
LinkedList удобен когда важнее быстродействие операций вставки/удаления, которые в LinkedList выполняются за константное время. Операции доступа по индексу производятся перебором с начала или конца (смотря что ближе) до нужного элемента. Дополнительные затраты на хранение связки между элементами.
Одним словом - если часто вставляете/удаляете - выбирайте в пользу LinkedList, в противном случае ArrayList

26.  Класс Hashset. Класс LinkedHashset. Класс TreeSet. Класс PriorityQueue.

Обобщенный класс HashSet представляет хеш-таблицу. Он наследует свой функционал от класса AbstractSet, а также реализует интерфейс Set.

Хеш-таблица представляет такую структуру данных, в которой все объекты имеют уникальный ключ или хеш-код. Данный ключ позволяет уникально идентифицировать объект в таблице. Для создания объекта HashSet можно воспользоваться одним из следующих конструкторов: HashSet(), HashSet(Collection<? extends E> col), HashSet(int capacity), HashSet(int capacity, float koef)
Класс LinkedHashSet расширяет класс HashSet, не добавляя никаких новых методов. Класс поддерживает связный список элементов набора в том порядке, в котором они вставлялись. Это позволяет организовать упорядоченную итерацию вставки в набор.
Обобщенный класс TreeSet<E> представляет структуру данных в виде дерева, в котором все объекты хранятся в отсортированном виде по возрастанию. TreeSet является наследником класса AbstractSet и реализует интерфейс NavigableSet, а следовательно, и интерфейс SortedSet.

В HashSet порядок элементов определяется по сложному алгоритму. Если порядок хранения для вас важен, используйте контейнер TreeSet, в котором объекты хранятся отсортированными по возрастанию в порядке сравнения или LinkedHashSet с хранением элементов в порядке добавления.

	PriorityQueue - коллекция, позволяющая эффективно удалять наименьший элемент. PriorityQueue является неограниченной очередью. Элементы упорядочены по умолчанию в естественном порядке или же отсортированы с помощью компаратора. PriorityQueue не позволяет добавлять null-значения и non-comparable объекты. Размер приоритетной очереди (PriorityQueue) неограничен, но мы можем указать начальный размер в момент его создания. Когда мы добавляем элементы в приоритетную очередь, её размер увеличивается автоматически. В PriorityQueue добавление/удаление элементов происходит за время O(log(n)). PriorityQueue не является потокобезопасной! Для этих целей в Java реализован класс PriorityBlockingQueue, реализующий интерфейс BlockingQueue. Именно он используется в многопоточной среде.

27.  Класс EnumSet. Доступ к коллекциям через итератор. Применение интерфейса Iterator. Цикл for в стиле for each как альтернатива итераторам
●	EnumSet - Специализированная реализация Set для использования с enum типами. Все элементы в наборе enum должны исходить из одного типа перечисления, который указывается явно или неявно при создании набора. Наборы Enum представлены внутри как битовые векторы. Это представление чрезвычайно компактно и эффективно. Пространственная и временная производительность этого класса должна быть достаточно хорошей, чтобы его можно было использовать в качестве высококачественной, безопасной для типов альтернативы традиционным «битовым флагам» на основе int. Даже массовые операции (такие как containsAll и continueAll) должны выполняться очень быстро, если их аргумент также является перечисляемым набором.
●	Итератор, возвращаемый методом итератора, перебирает элементы в их естественном порядке (порядке, в котором объявлены константы перечисления). Возвращаемый итератор является слабо непротиворечивым: он никогда не вызовет исключение ConcurrentModificationException и может отображать или не отображать последствия любых изменений набора, происходящих во время выполнения итерации.
●	В цикле for-each мы не можем изменить коллекцию, она вызовет ConcurrentModificationException, с другой стороны, с помощью итератора мы можем изменить коллекцию.
Изменение коллекции просто означает удаление элемента или изменение содержимого элемента, хранящегося в коллекции. Это происходит потому, что цикл for-each неявно создает итератор, но он не доступен пользователю, поэтому мы не можем изменять элементы в коллекциях.


28.  Сохранение объектов пользовательских классов в коллекциях. Интерфейс RandomAccess
Для сохранения объектов пользовательского типа в коллекцию, необходимо в шаблон коллекции вписать тип сохраняемого объекта
Type object=new Type();
ArrayList<Type> list=new ArrayList<>();
List.add(object);
RandomAccess предназначен для произвольного доступа, самым популярным дочерним классов от этого интерфейса является RandomAccessFile, который позволяет записывать и считывать с файла в произвольном месте данные.
  RandomAccessFile file = new RandomAccessFile(filePath, "rw");
    	// переходим на определенный индекс
    	file.seek(seek);
    	// запишем данные в этом месте
    	file.write(data.getBytes());
    	file.close();


Topic 3. Типы исключительных ситуаций и процесс их обработки
29.  Особенности обработки исключений. Типы исключений. Необработанные исключения. Необрабатываемые исключения
В Java все исключения делятся на два типа:
-        контролируемые исключения (checked) и
-        неконтролируемые исключения (unchecked), к которым относятся ошибки (Errors) и исключения времени выполнения (RuntimeExceptions, потомок класса Exception).
Контролируемые исключения представляют собой ошибки, которые можно и нужно обрабатывать в программе, к этому типу относятся все потомки класса Exception (но не RuntimeException).
-        Checked исключения, это те, которые должны обрабатываться блоком catch или описываться в сигнатуре метода. Unchecked могут не обрабатываться и не быть описанными.
-        Unchecked исключения в Java — наследованные от RuntimeException, checked — от Exception (не включая unchecked).
Checked исключения отличаются от Unchecked исключения в Java, тем что: Наличие\обработка Checked исключения проверяются на этапе компиляции. Наличие\обработка Unchecked исключения происходит на этапе выполнения.
30.  Использование блоков операторов try, catch. Вывод описания исключения. Применение нескольких операторов catch
try — данное ключевое слово используется для отметки начала блока кода, который потенциально может привести к ошибке.
catch — ключевое слово для отметки начала блока кода, предназначенного для перехвата и обработки исключений.
В Java имеется множество различных типов исключений, и мы можем разграничить их обработку, включив дополнительные блоки catch:
int[] numbers = new int[3];
try{
    numbers[6]=45;
    numbers[6]=Integer.parseInt("gfd");
}
catch(ArrayIndexOutOfBoundsException ex){
  	System.out.println("Выход за пределы массива");
}
catch(NumberFormatException ex){         	
    System.out.println("Ошибка преобразования из строки в число");
}
Если у нас возникает исключение определенного типа, то оно переходит к соответствующему блоку catch.

31.  Вложенные операторы try. Оператор throw. Оператор throws. Оператор finally. Встроенные в Java исключения. Класс ClassCastException
Блоки try могут быть вложенными друг в друга. Исключение, возникшее во внутреннем блоке try и не перехваченное связанным с ним блоком catch, распространяется далее во внешний блок try и обрабатывается связанным с ним блоком catch.
Чтобы сообщить о выполнении исключительных ситуаций в программе, можно использовать оператор throw. То есть с помощью этого оператора мы сами можем создать исключение и вызвать его в процессе выполнения.
public static void main(String[] args) {    	
        try{
            Scanner in = new Scanner(System.in);
            int x = in.nextInt();
            if(x>=30){
               throw new Exception("Число х должно быть меньше 30");
       	}
        }
        catch(Exception ex){ 	        
            System.out.println(ex.getMessage());
    	}
        System.out.println("Программа завершена");
	}  
}
Иногда метод, в котором может генерироваться исключение, сам не обрабатывает это исключение. В этом случае в объявлении метода используется оператор throws, который надо обработать при вызове этого метода. Например, у нас имеется метод вычисления факториала, и нам надо обработать ситуацию, если в метод передается число меньше 1:
public static int getFactorial(int num) throws Exception{ 	
    if(num<1) throw new Exception("The number is less than 1");
	int result=1;
    for(int i=1; i<=num;i++){            
    	result*=i;
	}
	return result;
}
С помощью оператора throw по условию выбрасывается исключение. В то же время метод сам это исключение не обрабатывает с помощью try..catch, поэтому в определении метода используется выражение throws Exception.
Теперь при вызове этого метода нам обязательно надо обработать выбрасываемое исключение:
public static void main(String[] args){     	
	try{
        int result = getFactorial(-6);        
        System.out.println(result);
	}
    catch(Exception ex){     	
        System.out.println(ex.getMessage());
	}
}
Без обработки исключение у нас возникнет ошибка компиляции, и мы не сможем скомпилировать программу.
Конструкция try..catch также может иметь блок finally. Однако этот блок необязательный, и его можно при обработке исключений опускать. Блок finally выполняется в любом случае, возникло ли исключение в блоке try или нет:
finally{
    System.out.println("Блок finally");
}
ClassCastException – это непроверенное исключение , которое сигнализирует о том, что код попытался привести ссылку на тип, к которому он не является подтипом. Независимо от того, явные или неявные, приведение ссылок Java к другому типу может привести к ClassCastException , если целевой тип не совпадает или не является потомком фактического типа.
32.  Создание собственных подклассов исключений. Цепочки исключений. Альтернативные средства обработки исключений
Чтобы создать свой класс исключений, надо унаследовать его от класса Exception. Например, у нас есть класс, вычисляющий факториал, и нам надо выбрасывать специальное исключение, если число, передаваемое в метод, меньше 1:
class Factorial{
	public static int getFactorial(int num) throws FactorialException{ 	
    	int result=1;
        if(num<1) throw new FactorialException("The number is less than 1", num);     	
        for(int i=1; i<=num;i++){            
            result*=i;
    	}
    	return result;
	}
}
class FactorialException extends Exception{
	private int number;
	public int getNumber(){return number;}
	public FactorialException(String message, int num){    
    	super(message);
 	number=num;	}
}
Здесь для определения ошибки, связанной с вычислением факториала, определен класс FactorialException, который наследуется от Exception и который содержит всю информацию о вычислении. В конструкторе FactorialException в конструктор базового класса Exception передается сообщение об ошибке: super(message). Кроме того, отдельное поле предназначено для хранения числа, факториал которого вычисляется.
Для генерации исключения в методе вычисления факториала выбрасывается исключение с помощью оператора throw: throw new FactorialException("Число не может быть меньше 1", num). Кроме того, так как это исключение не обрабатывается с помощью try..catch, то мы передаем обработку вызывающему методу, используя оператор throws: public static int getFactorial(int num) throws FactorialException
Теперь используем класс в методе main:
public static void main(String[] args){     	
	try{
    	int result = Factorial.getFactorial(6);
        System.out.println(result);
	}
    catch(FactorialException ex){        
        System.out.println(ex.getMessage());
   	 System.out.println(ex.getNumber());
	}
}
Цепочки исключений позволяют узнать, какое исключение привело к появлению другого исключения. Пример использования цепочки исключений:
try {
} catch (IOException e) {
	throw new SampleException("Other IOException", e);}


Когда одно исключение связано с другим, оно описывает причину этого исключения. Конструкторы класса Throwable поддерживают цепочные исключения в Java. Они заключаются в следующем –
 
У класса Throwable есть методы, которые поддерживают цепочку исключений –
 


Topic 4. Структурные элементы класса, методы взаимодействия объектов и организация наследования
33.  Общая форма определения класса. Порядок создания объектов. Методы класса. Возврат значения из метода класса. Использование параметров методов. Конструкторы класса
●	класс определяется с помощью ключевого слова сlass:
class Person{}
Любой объект может обладать двумя основными характеристиками: состояние - некоторые данные, которые хранит объект, и поведение - действия, которые может совершать объект.
Для хранения состояния объекта в классе применяются поля или переменные класса. Для определения поведения объекта в классе применяются методы. Например, класс Person, который представляет человека, мог бы иметь следующее определение:
class Person{
    String name; //поля
    int age;
  void displayInfo(){ //метод
        System.out.printf("Name: %s \tAge: %d\n", name, age);
}
}


Порядок создания объектов.
 
1.	Сначала для хранения объекта выделяется память.
2.	Далее Java-машина создает ссылку на этот объект (в нашем случае ссылка — это Cat cat).
3.	В завершение происходит инициализация переменных и вызов конструктора

Использование параметров методов
С помощью параметров мы можем передать в методы различные данные, которые будут использоваться для вычислений. Например:
 


Конструкторы класса

●	Кроме обычных методов классы могут определять специальные методы, которые называются конструкторами. Конструкторы вызываются при создании нового объекта данного класса. Конструкторы выполняют инициализацию объекта.
Если в классе не определено ни одного конструктора, то для этого класса автоматически создается конструктор без параметров.

Конструктор Person ( ):

 

34.  Параметризированные конструкторы класса. Сборка мусора и методы завершения. Метод finalize()
Параметризированные конструкторы – это конструкторы, получающие параметры.
ПРИМЕР:
 public class MyRect
{
	// внутренние переменные класса
	private int x, y, dx , dy; // скрытые - ключевое слово private
    // Конструктор класса
	// параметризированный конструктор с двумя параметрами
	MyRect(int dx, int dy)
    {
    	this.dx = dx;
    	this.dy = dy;
    	x = 0;
    	y = 0;
	}
Система «сборки мусора» в Java освобождает память от лишних объектов автоматически, действуя подспудно, незаметно и без каких-либо помех со стороны программиста. «Сборка мусора» происходит правильно. Если ссылки на объекты отсутствуют, то такие объекты считаются более ненужными, и занимаемая им память в доступе. Эта утилизированная память может быть затем распределена для других объектов.
«Сборка мусора» происходит лишь за время от времени по ходу программы. Она не возникает только потому, что существует или несколько объектов, которые больше не используются. Следовательно, нельзя заранее знать или получить "сбор мусора".
Метод finalize()
Существует возможность определить метод, который требует особого внимания перед удалением объекта из памяти. Этот метод можно, например, использовать для закрытия файла, открытия проверяемого поражения.
Для того, чтобы добавить в класс метод завершения, достаточно определить метод finalize(). Исполняющая система Java вызывает этот метод перед удалением объекта. В теле метода finalize() следует предварительное действие, которое должно быть выполнено перед удалением объекта.
Ниже приведена общая форма метода finalize().
class FDemo {
	int x;
	FDemo(int i) {
    	x = i;
	}
	// вызывается при утилизации объекта
	protected void finalize()  {
    	System.out.println("Finalizing " + x) ;
	}
	// формирует объект, который тотчас уничтожается
	void generator(int i) {
    	FDemo о = new FDemo(i);
	}
}

35.  Ключевое слово this. Управление доступом к элементам класса. Способы передачи аргументов методу
this используется для указания о том что используется поле этого класса,
public void setSize (int size) {
this.size=size;
}
Управление доступом к элементам класса
Для управления доступа используются модификаторы доступа private, public, protected, default.
public void setSize (int size)
{
this.size=size;
}
   public: публичный, общедоступный класс или член класса. Поля и методы, объявленные с модификатором public, видны другим классам из текущего пакета и из внешних пакетов.
   private: закрытый класс или член класса, противоположность модификатору public. Закрытый класс или член класса доступен только из кода в том же классе.
   protected: такой класс или член класса доступен из любого места в текущем классе или пакете или в производных классах, даже если они находятся в других пакетах
    Модификатор по умолчанию. Отсутствие модификатора у поля или метода класса предполагает применение к нему модификатора по умолчанию. Такие поля или методы видны всем классам в текущем пакете.

Способы передачи аргументов методу
Передача по значению (by value). Значения фактических параметров копируются. Вызываемый метод создает свою копию значений аргументов и затем ее использует. ...
public void setSize (int size)
{
this.size=size;
}
Передача по ссылке (by reference). Параметры передаются как ссылка (адрес) на исходную переменную.
public void setSize (ArrayList<Integer> list)
{
this.size=list.size();
}

36.  Перегрузка методов класса. Применение ключевого слова static. Использование методов с переменным числом аргументов
Перегрузка методов класса:
public void setSize (int size){
this.size=size;
}
public void setSize (int size,ArrayList<Integer> list){
this.size=size;
this.list=list;
}
Статические методы можно вызывать не используя ссылку на объект. В этом их ключевое отличие от обычных методов класса. Для объявления таких методов используется ключевое слово static. На методы, объявленные как static, накладывается следующие ограничения:
Они могут непосредственно вызывать только другие статические методы.
Им непосредственно доступны только статические переменные.
Они не могут делать ссылки типа this или super.
Пример использования статических методов:
public class StaticMethodClass {
static int staticVar = 3;
int nonStaticVar;
public void nonStaticMethod() {
System.out.println("Нестатический метод");
}
static void staticMethod(int localVar) {
System.out.println("localVar = " + localVar);
System.out.println("staticVar = " + staticVar);
//Нельзя обратиться к нестатической переменной из статического метода
//System.out.println("nonStaticVar = " + nonStaticVar);
}
Списки аргументов переменной длины обозначаются символом многоточия ( ... ). Ниже приведен пример метода vaTest(), принимающего переменное число аргументов(в том числе и нулевое).
// Метод vaTest() с переменным числом аргументов
// Объявление метода со списком аргументов переменной длины
static void vaTest(int ... v) {
System.out.println("Число аргументов: " + v.length);
System.out.println("Содержимое: ");
for(int i = 0; i < v.length; i++) {
System.out.println(" arg " + i + ": " + v[i]);
}
System.out.println();
}
 
 

Topic 5. Структурные механизмы языка программирования Java для реализации полиморфизма в программах. Пакеты и интерфейсы
37.  Пакеты как контейнеры классов. Интерфейсы как способ абстрагировать функционал класса от его реализации. Именование пакета. Импорт пакетов. Статический импорт
В Java классы объединяются в пакеты. Пакеты позволяют организовать классы логически в наборы. Организация классов в виде пакетов позволяет избежать конфликта имен между классами. Принадлежность к пакету позволяет гарантировать однозначность имен. Чтобы указать, что класс принадлежит определенному пакету, надо использовать директиву package, после которой указывается имя пакета:
package название_пакета;
Если нам надо использовать классы из других пакетов, то нам надо подключить эти пакеты и классы. То есть мы указываем полный путь к файлу в пакете при создании его объекта. Однако такое нагромождение имен пакетов не всегда удобно, и в качестве альтернативы мы можем импортировать пакеты и классы в проект с помощью директивы import, которая указывается после директивы package.
В java есть также особая форма импорта - статический импорт. Для этого вместе с директивой import используется модификатор static:
package study;
import static java.lang.System.*;
import static java.lang.Math.*;
 
public class Program {
    public static void main(String[] args) {
        double result = sqrt(20);
        out.println(result);
    } 
}
Здесь происходит статический импорт классов System и Math. Эти классы имеют статические методы. Благодаря операции статического импорта мы можем использовать эти методы без названия класса.  Например, писать не Math.sqrt(20), а sqrt(20), так как функция sqrt(), которая возвращает квадратный корень числа, является статической.
●	Интерфейсы определяют некоторый функционал, не имеющий конкретной реализации, который затем реализуют классы, применяющие эти интерфейсы. И один класс может применить множество интерфейсов.
Чтобы определить интерфейс, используется ключевое слово interface. Например:
interface Printable{
 		   void print();}

class Book implements Printable{}



38.  Объявление интерфейса. Реализация интерфейса. Доступ к реализациям через ссылки на интерфейсы

Интерфейсы определяют некоторый функционал, не имеющий конкретной реализации, который затем реализуют классы, применяющие эти интерфейсы. И один класс может применить множество интерфейсов.
Чтобы определить интерфейс, используется ключевое слово interface. Например:

	interface Animal {
   public void eat();
   public void travel();
}

Все методы интерфейса не имеют модификаторов доступа, но фактически по умолчанию доступ public, так как цель интерфейса - определение функционала для реализации его классом. Поэтому весь функционал должен быть открыт для реализации.

Чтобы класс применил интерфейс, надо использовать ключевое слово implements.

public class MammalInt implements Animal {

   public void eat() {
      System.out.println("Млекопитающее кушает");
   }

   public void travel() {
      System.out.println("Млекопитающее путешествует");
   } 

   public int noOfLegs() {
      return 0;
   }

   public static void main(String args[]) {
      MammalInt m = new MammalInt();
      m.eat();
      m.travel();
   }
}

Когда вы объявляете интерфейс, вы объявляете новый ссылочный тип данных. Вы можете использовать название интерфейса в качестве типа данных так же как и любые другие типы. 
Если вы объявляете переменную типа интерфейса, то вы можете можете присвоить ей объект любого класса, который реализует этот интерфейс.
Например, так как класс Animal реализует интерфейс Mammal, то переменная типа Animal может хранить ссылку на объект типа Mammal:

	Animal cat =new Mammal(4);
p.print();  

И если мы хотим обратиться к методам класса Mammal, которые определены не в интерфейсе Animal, а в самом классе Mammal, то нам надо явным образом выполнить преобразование типов.

39.  Переменные в интерфейсах. Расширение интерфейсов. Методы по умолчанию в интерфейсах. Вопросы множественного наследования. Применение статических методов в интерфейсе
Кроме методов в интерфейсах могут быть определены статические константы:
	interface Stateable{
    int OPEN = 1;
    int CLOSED = 0;
    void printState(int n);
}
Хотя такие константы также не имеют модификаторов, но по умолчанию они имеют модификатор доступа public static final, и поэтому их значение доступно из любого места программы.
Интерфейс расширяет другой интерфейс, как класс реализует интерфейс в наследовании интерфейса. Программа, которая демонстрирует расширение интерфейса в Java, имеет следующий вид:
interface A {
   void funcA();
}
interface B extends A {
   void funcB();
}
class C implements B {
   public void funcA() {
      System.out.println("This is funcA");
   }
   public void funcB() {
      System.out.println("This is funcB");
   }
}

В JDK 8 была добавлена такая функциональность как методы по умолчанию. И теперь интерфейсы кроме определения методов могут иметь их реализацию по умолчанию, которая используется, если класс, реализующий данный интерфейс, не реализует метод. Например, создадим метод по умолчанию в интерфейсе Printable:
interface Printable {
    default void print(){
        System.out.println("Undefined printable");
    }
}
Метод по умолчанию - это обычный метод без модификаторов, который помечается ключевым словом default. Затем в классе нам необязательно этот метод реализовать, хотя мы можем его и переопределить
	Механизм наследования очень удобен, но он имеет свои ограничения. В частности мы можем наследовать только от одного класса, в отличие, например, от языка С++, где имеется множественное наследование. В языке Java подобную проблему частично позволяют решить интерфейсы. Интерфейсы определяют некоторый функционал, не имеющий конкретной реализации, который затем реализуют классы, применяющие эти интерфейсы. И один класс может применить множество интерфейсов. Если нам надо применить в классе несколько интерфейсов, то они все перечисляются через запятую после слова implements
class Book implements Printable, Searchable{
    // реализация класса
}
Статические методы
Начиная с JDK 8 в интерфейсах доступны статические методы - они аналогичны методам класса:
interface Printable {
    void print();
    static void read(){
        System.out.println("Read printable");
    }
}
Чтобы обратиться к статическому методу интерфейса также, как и в случае с классами, пишут название интерфейса и метод:
public static void main(String[] args) {
         
    Printable.read();
}
Topic 6. Работа с файловой системой в Java и процесс сериализации объектов

40.  Чтение/запись данных из/в файлы(файлов). Процесс сериализации. Интерфейс Serializable

Запись:
Класс FileWriter является производным от класса Writer. Он используется для записи текстовых файлов.

Чтобы создать объект FileWriter, можно использовать один из следующих конструкторов:

FileWriter(File file)
FileWriter(File file, boolean append)
FileWriter(FileDescriptor fd)
FileWriter(String fileName)
FileWriter(String fileName, boolean append)

Так, в конструктор передается либо путь к файлу в виде строки, либо объект File, который ссылается на конкретный текстовый файл. Параметр append указывает, должны ли данные дозаписываться в конец файла (если параметр равен true), либо файл должен перезаписываться.

Запишем в файл какой-нибудь текст:

import java.io.*;
public class Program {
    public static void main(String[] args) {
        try(FileWriter writer = new FileWriter("notes3.txt", false))
        {
           // запись всей строки
            String text = "Hello Gold!";
            writer.write(text);
            // запись по символам
            writer.append('\n');
            writer.append('E');
            writer.flush();
        }
        catch(IOException ex){
            System.out.println(ex.getMessage());
        } 
    } 
}

В конструкторе использовался параметр append со значением false - то есть файл будет перезаписываться. Затем с помощью методов, определенных в базовом классе Writer производится запись данных.


Чтение:
Класс FileReader наследуется от абстрактного класса Reader и предоставляет функциональность для чтения текстовых файлов.

Для создания объекта FileReader мы можем использовать один из его конструкторов:

FileReader(String fileName) 
FileReader(File file)
FileReader(FileDescriptor fd)

А используя методы, определенные в базом классе Reader, произвести чтение файла:

import java.io.*;
 
public class Program {
 
    public static void main(String[] args) {
        
        try(FileReader reader = new FileReader("notes3.txt"))
        {
           // читаем посимвольно
            int c;
            while((c=reader.read())!=-1){
                 
                System.out.print((char)c);
            } 
        }
        catch(IOException ex){
             
            System.out.println(ex.getMessage());
        }   
    } 
}

Сериализация:

Сериализация — процесс перевода структуры данных в последовательность байтов. Обратной к операции сериализации является операция десериализации — создание структуры данных из битовой последовательности. Сериализация используется для передачи объектов по сети и для сохранения их в файлы.

Интерфейс Serializable:

В Java за процессы сериализации отвечает интерфейс Serializable. 
Этот интерфейс не определяет никаких методов, просто он служит указателем системе, что объект, реализующий его, может быть сериализован.
сериализовать можно только те объекты, которые реализуют интерфейс Serializable.



Рассмотри пример сериализации объекта класса Person.


import java.io.*;

class Home implements Serializable {
    private String home;

    public Home(String home) {
        this.home = home;
    }

    public String getHome() {
        return home;
    }
}

public class Person implements Serializable {
    private String name;
    private int countOfNiva;
    private String fatherName;
    private Home home;

    public Person(String name, int countOfNiva, String fatherName, Home home) {
        this.name = name;
        this.countOfNiva = countOfNiva;
        this.fatherName = fatherName;
        this.home = home;
    }

    @Override
    public String toString() {
        return "Person{" +
                "name='" + name + '\'' +
                ", countOfNiva=" + countOfNiva +
                ", fatherName='" + fatherName + '\'' +
                ", home=" + home +
                '}';
    }

    public static void main(String[] args) throws IOException, ClassNotFoundException {
        Home home = new Home("Vishnevaia 1");
        Person igor = new Person("Igor", 2, "Raphael", home);
        Person renat = new Person("Renat", 2, "Raphael", home);

        //Сериализация в файл с помощью класса ObjectOutputStream
        ObjectOutputStream objectOutputStream = new ObjectOutputStream(
                new FileOutputStream("person.out"));
        objectOutputStream.writeObject(igor);
        objectOutputStream.writeObject(renat);
        objectOutputStream.close();

41.  Автоматическое закрытие файла. Пакет java.io для ввода вывода. Классы и интерфейсы ввода-вывода.

Любой файл, который открывается и используется должен быть закрыт с помощью вызова метода close(). Если этого не сделать, то это может привести к вытоку памяти и связанных с этим осложнений. Поэтому вылавливается неожиданный выход в try и закрывается файл
file.close();
Пакет java.io содержит почти каждый класс, который может потребоваться Вам для совершения ввода и вывода в Java. Все данные потоки представлены потоком ввода и адресом вывода. Поток в пакете java.io осуществляет поддержку различных данных, таких как примитивы, объекты, локализованные символы и т.д.

Потоки

Потоки в Java определяются в качестве последовательности данных. Существует два типа потоков:

InputStream – поток ввода используется для считывания данных с источника.

OutputStream – поток вывода используется для записи данных по месту назначения. 

42.  Класс File. Каталоги. Применение интерфейса FileNameFilter. Класс FileInputStream. Класс FileOutputStream. Класс

Класс File, определенный в пакете java.io, не работает напрямую с потоками. Его задачей является управление информацией о файлах и каталогах. Хотя на уровне операционной системы файлы и каталоги отличаются, но в Java они описываются одним классом File.

В зависимости от того, что должен представлять объект File - файл или каталог, мы можем использовать один из конструкторов для создания объекта:
File(String путь_к_каталогу)
File(String путь_к_каталогу, String имя_файла)
File(File каталог, String имя_файла)

Например:
	// создаем объект File для каталога
File dir1 = new File("C://SomeDir");
// создаем объекты для файлов, которые находятся в каталоге
File file1 = new File("C://SomeDir", "Hello.txt");
File file2 = new File(dir1, "Hello2.txt");

Класс File имеет ряд методов, которые позволяют управлять файлами и каталогами. Рассмотрим некоторые из них:
●	boolean createNewFile(): создает новый файл по пути, который передан в конструктор. В случае удачного создания возвращает true, иначе false
●	boolean delete(): удаляет каталог или файл по пути, который передан в конструктор. При удачном удалении возвращает true.
●	boolean exists(): проверяет, существует ли по указанному в конструкторе пути файл или каталог. И если файл или каталог существует, то возвращает true, иначе возвращает false
●	String getAbsolutePath(): возвращает абсолютный путь для пути, переданного в конструктор объекта
●	String getName(): возвращает краткое имя файла или каталога
●	String getParent(): возвращает имя родительского каталога
●	boolean isDirectory(): возвращает значение true, если по указанному пути располагается каталог
●	boolean isFile(): возвращает значение true, если по указанному пути находится файл
●	boolean isHidden(): возвращает значение true, если каталог или файл являются скрытыми
●	long length(): возвращает размер файла в байтах
●	long lastModified(): возвращает время последнего изменения файла или каталога. Значение представляет количество миллисекунд, прошедших с начала эпохи Unix
●	String[] list(): возвращает массив файлов и подкаталогов, которые находятся в определенном каталоге
●	File[] listFiles(): возвращает массив файлов и подкаталогов, которые находятся в определенном каталоге
●	boolean mkdir(): создает новый каталог и при удачном создании возвращает значение true
●	boolean renameTo(File dest): переименовывает файл или каталог

Если объект File представляет каталог, то его метод isDirectory() возвращает true. И поэтому мы можем получить его содержимое - вложенные подкаталоги и файлы с помощью методов list() и listFiles(). Получим все подкаталоги и файлы в определенном каталоге:
import java.io.File;
public class Program {
    public static void main(String[] args) {
        // определяем объект для каталога
        File dir = new File("C://SomeDir");
        // если объект представляет каталог
        if(dir.isDirectory())
        {
            // получаем все вложенные объекты в каталоге
            for(File item : dir.listFiles()){
                 if(item.isDirectory()){
                     System.out.println(item.getName() + "  \t folder");
                 }
                 else{
                     System.out.println(item.getName() + "\t file");
                 }
             }
        }
    }
}

Интерфейс FilenameFilter может быть реализован для фильтрации имен файлов в определенной папке. Интерфейс FilenameFilter содержит метод boolean accept(File dir, String name). Класс должен реализовывать этот метод, а каждый тестируемый файл должен быть включен в общий список файлов. Например, используем FilenameFilter, чтобы найти все файлы определенного расширения в определенной папке:

import java.io.File;
import java.io.FilenameFilter;
public class FileNameFilterExample {
    public static void main(String[] args) {
        // будем искать в папке tmp
        String dir = "/Users/prologistic/tmp";
        // в этой папке будем искать файлы с расширением .xml
        String ext = ".xml";
        // вызываем метод поиска файлов с расширением .xml в папке tmp
        findFiles(dir, ext);
    }
    // метод поиска
    private static void findFiles(String dir, String ext) {
        File file = new File(dir);
        if(!file.exists()) System.out.println(dir + " папка не существует");
        File[] listFiles = file.listFiles(new MyFileNameFilter(ext));
        if(listFiles.length == 0){
            System.out.println(dir + " не содержит файлов с расширением " + ext);
        }else{
            for(File f : listFiles)
                System.out.println("Файл: " + dir + File.separator + f.getName());
        }
    }
    // Реализация интерфейса FileNameFilter
    public static class MyFileNameFilter implements FilenameFilter{     
        private String ext;
        public MyFileNameFilter(String ext){
            this.ext = ext.toLowerCase();
        }
        @Override
        public boolean accept(File dir, String name) {
            return name.toLowerCase().endsWith(ext);
        }
    }
}

Класс FileOutputStream предназначен для записи байтов в файл. Он является производным от класса OutputStream, поэтому наследует всю его функциональность.

Через конструктора класса FileOutputStream задается файл, в который производится запись. Класс поддерживает несколько конструкторов:
FileOutputStream(String filePath)
FileOutputStream(File fileObj)
FileOutputStream(String filePath, boolean append)
FileOutputStream(File fileObj, boolean append)

Файл задается либо через строковый путь, либо через объект File. Второй параметр - append задает способ записи: eсли он равен true, то данные дозаписываются в конец файла, а при false - файл полностью перезаписывается. Для автоматического закрытия файла и освобождения ресурса объект FileOutputStream создается с помощью конструктции try...catch.

Для считывания данных из файла предназначен класс FileInputStream, который является наследником класса InputStream и поэтому реализует все его методы. Для создания объекта FileInputStream мы можем использовать ряд конструкторов. Наиболее используемая версия конструктора в качестве параметра принимает путь к считываемому файлу:
FileInputStream(String fileName) throws FileNotFoundException

Если файл не может быть открыт, например, по указанному пути такого файла не существует, то генерируется исключение FileNotFoundException.

Считаем данные из ранее записанного файла и выведем на консоль:
import java.io.*;
public class Program {
    public static void main(String[] args) {
        try(FileInputStream fin=new FileInputStream("C://SomeDir//notes.txt"))
        {
            System.out.printf("File size: %d bytes \n", fin.available());
            int i=-1;
            while((i=fin.read())!=-1){
                System.out.print((char)i);
            }   
        }
        catch(IOException ex){
            System.out.println(ex.getMessage());
        } 
    }
}

В данном случае мы считываем каждый отдельный байт в переменную i:
	while((i=fin.read())!=-1)
Когда в потоке больше нет данных для чтения, метод возвращает число -1. Затем каждый считанный байт конвертируется в объект типа char и выводится на консоль.

Классы FileInputStream и FileOutputStream предназначены прежде всего для записи двоичных файлов, то есть для записи и чтения байтов. И хотя они также могут использоваться для работы с текстовыми файлами, но все же для этой задачи больше подходят другие классы.

Topic 7. Многопоточное программирование

43.  Модель потоков исполнения в Java. Приоритеты потоков. Синхронизация исполнения потоков

Приоритеты потоков:
Каждому потоку исполнения в Java присваивается свой приоритет, который определяет поведение данного потока по отношению к другим потокам. Приоритеты потоков исполнения задаются целыми числами (обычно от 1 до 10), определяющими относительный приоритет одного потока над другими.
Приоритет потока исполнения используется для принятия решения при переходе от одного потока исполнения к другому. Это так называемое переключение контекста. Задается с помощью метода public final void setPriority(int newPriority).
По умолчанию приоритет потока 5.
Существуют следующие константы для определения приоритета потока:
•	Thread.MIN_PRIORITY (1)
•	Thread.NORM_PRIORITY (5)
•	Thread.MAX_PRIORITY (10)
НЕ полагайтесь на приоритет потоков при проектировании многопоточных приложений! Скорее всего планировщик потоков будет использовать приоритеты при выборе следующего потока на выполнение, но это НЕ гарантируется.
Синхронизация потоков:

Все потоки, принадлежащие одному процессу, разделяют некоторые общие ресурсы (адресное пространство, открытые файлы). Когда два или более потоков имеют доступ к одному разделенному ресурсу, они нуждаются в обеспечении того, что ресурс будет использован только одним потоком одновременно. Процесс, с помощью которого это достигается, называется синхронизацией.
Синхронизация достигается в Java использованием зарезервированного слова synchronized. Вы можете использовать его в своих классах определяя синхронизированные методы или блоки. Вы не сможете использовать synchronized в переменных или атрибутах в определении класса.

 
 
При создании синхронизированного блока кода после оператора synchronized идет объект-заглушка: synchronized(res). Причем в качестве объекта может использоваться только объект какого-нибудь класса, но не примитивного типа.

Результат работы синхронизированных потоков:
 

44.  Класс Thread и интерфейс Runnable. Главный поток исполнения. Реализация интерфейса Runnable. Расширение класса Тhread. Выбор способа создания потоков исполнения
Создатели Java предоставили две возможности создания потоков: реализация (implementing) интерфейса Runnable и расширение(extending) класса Thread. Расширение класса - это путь наследования методов и переменных класса родителя. В этом случае можно наследоваться только от одного родительского класса Thread. Данное ограничение внутри Java можно преодолеть реализацией интерфейса Runnable, который является наиболее распространенным способом создания потоков.
В классе Thread определены семь перегруженных конструкторов, большое количество методов, предназначенных для работы с потоками, и три константы (приоритеты выполнения потока).
Самый простой способ создания – реализация интерфейса Runnable, который требует определения в классе реализации метода: public void run (); , устанавливающего в программе точку входа для запуска нового конкурирующего потока выполнения. Интерфейс Runnable содержит только один метод run() :
Метод run() выполняется при запуске потока. После определения объекта Runnable он передается в один из конструкторов класса Thread.
Примеры создания потоков
• 	анонимный класс
// Создание потока
Thread t = new Thread(new Runnable() {
    public void run() {
        System.out.println("Hello");
}
});
t.start(); // Запуск потока
 
• 	класс, реализующий Runnable и метод run()
public class myTask implements Runnable {
  	public void run() {
            	// действия
  	}
}
Thread t = new Thread(new myTask());  // Создание потока
t.start();  // Запуск потока
 
• 	Класс, наследующийся от Thread и реализующий метод run()
public class myTask extends Thread {
  	public void run() {
            	// действия
  	}
}
Thread t = new myTask();  // Создание потока
t.start();  // Запуск потока
В данном случае также можно вызвать start() в конструкторе.
Когда запускается любое приложение, то начинает выполняться поток, называемый главным потоком (main). От него порождаются дочерние потоки. Главный поток, как правило, является последним потоком, завершающим выполнение программы. Главный поток создается автоматически с именем main  и приоритетом 5 по умолчанию.
Несмотря на то, что главный поток создается автоматически, им можно управлять через объект класса Thread. Для этого нужно вызвать метод currentThread(), после чего можно управлять потоком.
Класс Thread содержит несколько методов для управления потоками.
• 	getName() - получить имя потока
• 	getPriority() - получить приоритет потока
• 	isAlive() - определить, выполняется ли поток
• 	join() - ожидать завершение потока
• 	run() - запуск потока
• 	sleep() - приостановить поток на заданное время
• 	start() - запустить поток вызовом метода start()


45.  Создание нескольких потоков исполнения. Применение методов isAlive() и join(). Синхронизация выполнения потоков. Применение синхронизированных методов. Оператор synchronized

При многозадачности на основе потоков наименьшей единицей диспетчеризации является отдельный поток исполнения. Таким образом многозадачность на основе процессов имеет с «общей картиной» функционирования системы, а многозадачность на основе потоков – отдельными деталями. Важным преимуществом является сведение к минимуму времени ожидания.   
Определить, был ли поток исполнения завершен, можно двумя способами. Во­ первых, для этого потока можно вызвать метод isAlive(), определенный в классе Thread. Ниже приведена общая форма этого метода:
final Boolean isAlive()
Метод isAlive() возвращает логическое значение true, если поток, для кото­рого он вызван, еще исполняется. В противном случае он возвращает логическое значение false.

И во-вторых, в классе Thread имеется метод join(), который применяется чаще, чем метод isAlive(), чтобы дождаться завершения потока исполнения.

Ниже приведена общая форма этого метода:
final void join() throws InetrruptedException
Этот метод ожидает завершения того потока исполнения, для которого он вы­зван. Его имя отражает следующий принцип: вызывающий поток ожидает, когда указанный поток присоединится к нему.
Дополнительные формы метода jоin() по­зволяют указывать максимальный промежуток времени , в течение которого тре­буется ожидать завершения указанного потока исполнения.
Потоки взаимодействуют в первую очередь путем совместного доступа к полям и объектам, на которые ссылаются поля. Эта форма связи чрезвычайно эффективна, но делает возможным два вида ошибок: вмешательство потока и ошибки согласованности памяти . Инструментом, необходимым для предотвращения этих ошибок, является синхронизация .

Однако синхронизация может привести к конфликту потоков , который возникает, когда два или более потока пытаются одновременно получить доступ к одному и тому же ресурсу, и заставляет среду выполнения Java выполнять один или несколько потоков медленнее или даже приостанавливать их выполнение.

Одним из способов синхронизации является использование ключевого слова synchronized. Этот оператор предваряет блок кода или метод, который подлежит синхронизации. Для его применения изменим класс CountThread:
class CountThread implements Runnable{
 
    CommonResource res;
    CountThread(CommonResource res){
        this.res=res;
    }
    public void run(){
        synchronized(res){
            res.x=1;
            for (int i = 1; i < 5; i++){
                System.out.printf("%s %d \n", Thread.currentThread().getName(), res.x);
                res.x++;
                try{
                    Thread.sleep(100);
                }
                catch(InterruptedException e){}
            }
        }
    }
}
При создании синхронизированного блока кода после оператора synchronized идет объект-заглушка: synchronized(res). Причем в качестве объекта может использоваться только объект какого-нибудь класса, но не примитивного типа.

Семафоры представляют еще одно средство синхронизации для доступа к ресурсу. В Java семафоры представлены классом Semaphore, который располагается в пакете java.util.concurrent.

Для управления доступом к ресурсу семафор использует счетчик, представляющий количество разрешений. Если значение счетчика больше нуля, то поток получает доступ к ресурсу, при этом счетчик уменьшается на единицу. После окончания работы с ресурсом поток освобождает семафор, и счетчик увеличивается на единицу. Если же счетчик равен нулю, то поток блокируется и ждет, пока не получит разрешение от семафора.

Для получения разрешения у семафора надо вызвать метод acquire(), после окончания работы с ресурсом полученное ранее разрешение надо освободить с помощью метода release():

public void run(){
         
        try{
            System.out.println(name + " ожидает разрешение");
            sem.acquire();
            res.x=1;
            for (int i = 1; i < 5; i++){
                System.out.println(this.name + ": " + res.x);
                res.x++;
                Thread.sleep(100);
            }
        }
        catch(InterruptedException e){System.out.println(e.getMessage());}
        System.out.println(name + " освобождает разрешение");
        sem.release();
    }

Для управления доступом к общему ресурсу в качестве альтернативы оператору synchronized мы можем использовать блокировки. Функциональность блокировок заключена в пакете java.util.concurrent.locks.

Вначале поток пытается получить доступ к общему ресурсу. Если он свободен, то на него накладывает блокировку. После завершения работы блокировка с общего ресурса снимается. Если же ресурс не свободен и на него уже наложена блокировка, то поток ожидает, пока эта блокировка не будет снята.

Классы блокировок реализуют интерфейс Lock, который определяет следующие методы:

void lock(): ожидает, пока не будет получена блокировка

void lockInterruptibly() throws InterruptedException: ожидает, пока не будет получена блокировка, если поток не прерван

boolean tryLock(): пытается получить блокировку, если блокировка получена, то возвращает true. Если блокировка не получена, то возвращает false. В отличие от метода lock() не ожидает получения блокировки, если она недоступна

void unlock(): снимает блокировку

Организация блокировки в общем случае довольно проста: для получения блокировки вызывается метод lock(), а после окончания работы с общими ресурсами вызывается метод unlock(), который снимает блокировку.

ПРИМЕР:
class CountThread implements Runnable{
    CommonResource res;
    ReentrantLock locker;
    CountThread(CommonResource res, ReentrantLock lock){
        this.res=res;
        locker = lock;
    }
    public void run(){
        locker.lock(); // устанавливаем блокировку
        try{
            res.x=1;
            for (int i = 1; i < 5; i++){
                res.x++;
                Thread.sleep(100);
            }
        }
        catch(InterruptedException e){
            System.out.println(e.getMessage());
        }
        finally{
            locker.unlock(); // снимаем блокировку
        }}}

46.  Взаимодействие потоков исполнения. Взаимная блокировка. Приостановка, возобновление и остановка потоков исполнения. Получение состояния потока исполнения	
 В Java потоки могут взаимодействовать между собой с помощью различных конструкций. Например с помощью методов wait(), notify(), notifyAll()
 
-          wait(): освобождает монитор и переводит вызывающий поток в состояние ожидания до тех пор, пока другой поток не вызовет метод notify()
-          notify(): продолжает работу потока, у которого ранее был вызван метод wait()
-          notifyAll(): возобновляет работу всех потоков, у которых ранее был вызван метод wait()
Класс Phaser позволяет синхронизировать потоки, представляющие отдельную фазу или стадию выполнения общего действия. Phaser определяет объект синхронизации, который ждет, пока не завершится определенная фаза. Затем Phaser переходит к следующей стадии или фазе и снова ожидает ее завершения.

Для создания объекта Phaser используется один из конструкторов:
Phaser()
Phaser(int parties)
Phaser(Phaser parent)
Phaser(Phaser parent, int parties)
Параметр parties указывает на количество участников (грубо говоря, потоков), которые должны выполнять все фазы действия. Первый конструктор создает объект Phaser без каких-либо участников. Второй конструктор регистрирует передаваемое в конструктор количество участников. Третий и четвертый конструкторы также устанавливают родительский объект Phaser.
Основные методы класса Phaser:

int register(): регистрирует участника, который выполняет фазы, и возвращает номер текущей фазы - обычно фаза 0

int arrive(): сообщает, что участник завершил фазу, и возвращает номер текущей фазы

int arriveAndAwaitAdvance(): аналогичен методу arrive, только при этом заставляет phaser ожидать завершения фазы всеми остальными участниками

int arriveAndDeregister(): сообщает о завершении всех фаз участником и снимает его с регистрации. Возвращает номер текущей фазы или отрицательное число, если синхронизатор Phaser завершил свою работу

int getPhase(): возвращает номер текущей фазы

ПРИМЕРЫ:
public class Program {
    public static void main(String[] args) {
        Phaser phaser = new Phaser(1);
        new Thread(new PhaseThread(phaser, "PhaseThread 1")).start();
        new Thread(new PhaseThread(phaser, "PhaseThread 2")).start();
       
        // ждем завершения фазы 0
        int phase = phaser.getPhase();
        phaser.arriveAndAwaitAdvance();
        System.out.println("Фаза " + phase + " завершена");
        // ждем завершения фазы 1
        phase = phaser.getPhase();
        phaser.arriveAndAwaitAdvance();
        System.out.println("Фаза " + phase + " завершена");
         
        // ждем завершения фазы 2
        phase = phaser.getPhase();
        phaser.arriveAndAwaitAdvance();
        System.out.println("Фаза " + phase + " завершена");
        phaser.arriveAndDeregister();
    }}
public void run(){           //Метод run у PhaseThread(см. выше)
        System.out.println(name + " выполняет фазу " + phaser.getPhase());
        phaser.arriveAndAwaitAdvance(); // сообщаем, что первая фаза достигнута
         
        System.out.println(name + " выполняет фазу " + phaser.getPhase());
        phaser.arriveAndAwaitAdvance(); // сообщаем, что вторая фаза достигнута
 
        System.out.println(name + " выполняет фазу " + phaser.getPhase());
        phaser.arriveAndDeregister(); // сообщаем о завершении фаз и удаляем с регистрации объекты 
    }

Остановка потока:
Распространенный способ завершения потока представляет опрос логической переменной. И если она равна, например, false, то поток завершает бесконечный цикл и заканчивает свое выполнение.

Еще один способ вызова завершения или прерывания потока представляет метод interrupt(). Вызов этого метода устанавливает у потока статус, что он прерван. 

class JThread extends Thread {
    JThread(String name){
        super(name);
    }
    public void run(){
        System.out.printf("%s started... \n", Thread.currentThread().getName());
        int counter=1; // счетчик циклов
        while(!isInterrupted()){
            System.out.println("Loop " + counter++);
        }
        System.out.printf("%s finished... \n", Thread.currentThread().getName());
    }
}
public class Program {
    public static void main(String[] args) { 
        System.out.println("Main thread started...");
        JThread t = new JThread("JThread");
        t.start();
        try{
            Thread.sleep(150);
            t.interrupt();
            Thread.sleep(150);
        }
        catch(InterruptedException e){
            System.out.println("Thread has been interrupted");
        }
        System.out.println("Main thread finished...");
    }}
После создания, поток выполнения может находиться в нескольких состояниях. В языке Java состояния потоков выполнения определяются заранее определенными константами из перечисления State класса Thread. Ниже приведено описание этих состояний
BLOCKED 	- Поток приостановил выполнение потому что ожидает получения блокировки
NEW     	- Поток создан, но он еще не начал своего выполнения
RUNNABLE   - Поток сейчас выполняется или начнет выполняться, когда получит
             доступ к центральному процессору
TERMINATED - Поток приостановил выполнение на заданный промежуток времени
             после вызова методов sleep(), wait(), join()
WAITING 	- Поток приостановил выполнение до ожидания некоторого действия (вызова методов wait() или join() без указанного времени ожидания)

Для получения состояния потока выполнения используется метод getState() класса Thread. Общая форма метода следующая:
public Thread.State getState()


Topic 8. Средства языка Java для организации работы в сети. Основные классы и ин- терфейсы реализации сетевого взаимодействия

47.  Архитектура клиент-сервер. Сетевые классы и интерфейсы Java для работы в сети. Адресация в сети Internet. Классы Inet4Address, Inet6Address. Класс InetAddress. Фабричные методы создания экземпляров класса InetAddress

Пакет java.net обеспечивает поддержку двух общих сетевых протоколов:
●	TCP - TCP - это протокол управления передачей, который обеспечивает надежную связь между двумя приложениями. В Java TCP обычно используется через Интернет-протокол, который называется TCP/IP.
●	UDP - UDP - это протокол пользовательских дейтаграмм, протокол без установления соединения, который позволяет передавать пакеты данных между приложениями.
В качестве класса для работы с сервлетами(протокол HTTP) используется HttpServlet. 
Основными протоколами, по которым происходит обмен информации в Интернет, является стек (список) протоколов TCP/IP (транспортного и адресного протокола)- цифровая адресация
.В основе DNS –адресации лежит структура доменов. 
Кроме цифрового и символьного адреса в Интернет предусмотрены уникальные адреса любого ресурса.
Такой уникальный адрес ресурса называется URL (Uniform Resource Locator) или это адрес документа в Интернет.
Класс InetAddress - это абстракция, представляющая IP-адрес (интернет-протокол). Он имеет два подкласса:
●	Inet4Address для адресов IPv4.
●	Inet6Address для адресов IPv6.
Но,в большинстве случаев,нет необходимости иметь дело непосредственно с подклассами,так как абстракция InetAddress должна охватывать большую часть необходимой функциональности.
Не все системы поддерживают протокол IPv6, и хотя сетевой стек Java попытается обнаружить его и прозрачно использовать, если он доступен, также можно отключить его использование с помощью системного свойства. В случае, когда IPv6 недоступен или явно отключен, Inet6Address больше не является допустимым аргументом для большинства сетевых операций. Хотя такие методы, как InetAddress.getByName(java.lang.String) , гарантированно не возвращают Inet6Address при поиске имен хостов, можно создать такой объект, передав литералы. В этом случае большинство методов при вызове с Inet6Address будут вызывать исключение.
Фабричные методы создания экземпляров класса InetAddress

public static  InetAddress getLocalHost();
public static  InetAddress
  getByName(String host);
public static  InetAddress[]
  getAllByName(String host);
InetAddress iaLocalAddress = null;
try
{
  iaLocalAddress =  InetAddress.getLocalHost();
}
catch(UnknownHostException ex)
{
  System.out.println(ex.toString()); 
}

48. Понятие сокета, порта, адреса в сети. Клиентские сокеты по протоколу TCP/IP в Java. Зарезервированные адреса и порты. Понятие протокола. Примеры протоколов, используемых при передаче данных по сети.
Сокет – это один конец двустороннего канала связи между двумя программами, работающими в сети. Соединяя вместе два сокета, можно передавать данные между разными процессами (локальными или удаленными). Сокет определяется номером порта и IP-адресом.
Порт – это число, указываемое при запросе на соединение (диапазон от 1 до 65535). То есть это «дверь», через которую программа (операционная система) может управлять данным устройством (считывать данные, заносить их).
IP-адрес – уникальный числовой идентификатор устройства в компьютерной сети, работающей по протоколу IP.
Сокеты в Java бывают двух видов:
•	Серверные (класс ServerSocket) – находятся в постоянной готовности принять новое подключение, то есть как бы «слушают» сеть;
•	Клиентские (класс Socket) – пытаются вызвать сервер для начала обмена данными.
Для работы с классами сокетов в Java необходимо подключить библиотеку import java.net.*;
Сокеты по протоколу ТСР/IP служат для реализации надежных двунаправленных, постоянных, двухточечных, потоковых соединений между хостами в Интернете.
При создании объекта типа Socket неявно устанавливается соединение клиента с сервером.
Выявить это соединение нельзя никакими методами или конструкторами. Ниже перечислены два конструктора класса Socket, предназначенные для создания клиентских сокетов.
// Создает сокет, подключаемый к указанному имени_хоста и порту
Socket(String имя_хоста, int порт) throws UnknownHostException, IOException
// Создает сокет, используя уже существующий объект типа InetAddress и указанный порт
Socket(InetAddress IP-адрес, int порт) throws IOException
Протокол — это организованный набор команд, которые определяют, как данные передаются между различными устройствами в одной сети (TCP/UDP).
Зарезервированные адреса и порты
Если в качестве сервера используется этот же компьютер без сетевого подключения, в качестве IP-адреса указывается 127.0.0.1 или localhost. Для явной идентификации услуг к IP-адресу присоединяется номер порта через двоеточие, например 217.21.43.10:443. Здесь указан номер порта 443. Номера портов от 1 до 1024 могут быть заняты для внутреннего использования, например, если порт явно не указан, браузер воспользуется значением по умолчанию: 20 — FTP-данные, 21 — FTP-управление, 53 — DNS, 80 — HTTP, 25 — SMTP, 110 — POP3, 119 — NNTP. К серверу можно подключиться с помощью различных портов. Каждый порт указывает конкретное место соединения на указанном компьютере и предоставляет определенную услугу.
Примеры протоколов, используемых при передаче данных по сети
В стеке протоколов TCP/IP используются следующие прикладные протоколы:
HTTP(s) — Hypertext Transfer Protocol (WWW);
NNTP — Network News Transfer Protocol (группы новостей);
SMTP — Simple Mail Transfer Protocol (посылка почты);
POP3 — Post Office Protocol (чтение почты с сервера);
FTP — File Transfer Protocol (протокол передачи файлов)
49. Класс URL. Исключительные ситуации и их обработка при передаче данных по сети. Типы исключений, возникающих при передаче данных по сети. Класс URLConnection. Исключение MalformedURLException
URL обозначает унифицированный указатель ресурса и представляет ресурс во Всемирной компьютерной сети, такой как веб-страница или каталог FTP (протокол пересылки файлов).
Класс java.net.URL представляет URL и имеет полный набор методов для управления URL в Java.
Класс URL имеет несколько конструкторов для создания URL, включая следующие:
 
Методы:
  и др.
java.net.URLConnection – абстрактный класс, подклассы которого представляют различные типы подключений URL. Методы:
  и др.
URL url = new URL("https://www.amrood.com");
URLConnection urlConnection = url.openConnection();

MalformedURLException расширяет IOException и указывает на то, что произошел неверный URL-адрес.

50. Серверные и клиентские сокеты по протоколу TCP/IP в Java. Использование многопоточности при реализации клиент-серверных соединений.
Сокеты по протоколу ТСР/IP служат для реализации надежных двунаправленных, постоянных, двухточечных, потоковых соединений между хостами в Интернете.
Сокет может служить для подключения системы ввода-вывода в Java к другим программам, которые могут находиться как на локальной машине, таки на любой другой машине в Интернете.
В Java поддерживаются две разновидности сокетов по протоколу ТСР /IP: один - для серверов, другой - для клиентов.
Класс ServerSocket служит "приемником", ожидая подключения клиентов прежде, чем предпринять какие-нибудь действия. Иными словами, класс ServerSocket предназначен для серверов, тогда как класс Socket - для клиентов.
Он служит для подключения к серверным сокетам и инициирования обмена данными по сетевому протоколу. Клиентские сокеты чаще всего применяются в прикладных программах на Java.
При создании объекта типа Socket неявно устанавливается соединение клиента с сервером.
Выявить это соединение нельзя никакими методами или конструкторами. Ниже перечислены два конструктора класса Socket, предназначенные для создания клиентских сокетов.
 
В классе Socket определяется ряд методов экземпляра. Например, объект типа Socket может быть просмотрен в любой момент для извлечения сведений о связанных с ним адресе и порте.
Для доступа к потокам ввода-вывода, связанным с классом Socket, можно воспользоваться методами getInputStream() и getOuptutStream(), перечисленными ниже.
Каждый из этих методов может сгенерировать исключение типа IOException, если сокет оказался недействительным из-за потери соединения.
Эти потоки ввода-вывода используются для передачи и приема данных таким же образом, как и потоки ввода-вывода.
●	InputStream getInputStream() throws IOException - возвращает объект типа InetAddress, связанный с вызывающим сокетом
●	OutputStream getOutputStream() throws IOException - возвращает объект типа OutputStream, связанный с вызывающим сокетом
Имеется и ряд других методов, в том числе метод connect(), позволяющий указать новое соединение; метод isConnected(), возвращающий логическое значение true, если сокет подключен к серверу; метод isBound(), возвращающий логическое значение true, если сокет привязан к адресу; а также метод isClosed(), возвращающий логическое значение true, если сокет закрыт.
Чтобы закрыть сокет, достаточно вызвать метод close(). Закрытие сокета приводит также к закрытию связанных с ним потоков ввода-вывода.
Начиная с версии JDК 7 класс Socket реализует также интерфейс AutoCloseabe. Это означает, что управление соке том можно организовать в блоке оператора try с ресурсами.
При помощи многопоточности мы можем выделить в приложении несколько потоков, которые будут выполнять различные задачи одновременно. Если у нас, допустим, графическое приложение, которое посылает запрос к какому-нибудь серверу или считывает и обрабатывает огромный файл, то без многопоточности у нас бы блокировался графический интерфейс на время выполнения задачи. А благодаря потокам мы можем выделить отправку запроса или любую другую задачу, которая может долго обрабатываться, в отдельный поток.
Проблемы, которые решает многопоточность в Java
1.	Одновременно выполнять несколько действий.
2.	Ускорить вычисления.
В Java функциональность отдельного потока заключается в классе Thread. И чтобы создать новый поток, нам надо создать объект этого класса. Но все потоки не создаются сами по себе. Когда запускается программа, начинает работать главный поток этой программы. От этого главного потока порождаются все остальные дочерние потоки.
По умолчанию именем главного потока будет main.
Для управления потоком класс Thread предоставляет еще ряд методов. 
Есть две конкретные проблемы, которые может вызвать использование многопоточности — взаимная блокировка (deadlock) и состояние гонки (race condition). 
Deadlock — ситуация, при которой несколько потоков находятся в состоянии ожидания ресурсов, занятых друг другом, и ни один из них не может продолжать выполнение.
Состояние гонки — ошибка проектирования многопоточной системы или приложения, при которой работа системы или приложения зависит от того, в каком порядке выполняются части кода.

51.	Использование протокола UDP. Передача дейтаграмм. Особенности передачи данных при использовании протокола UDP. Класс DatagramSocket. Класс DatagramPacket.
UDP — очень быстрый протокол, поскольку в нем определен самый минимальный механизм, необходимый для передачи данных. Конечно, он имеет некоторые недостатки. Сообщения поступают в любом порядке, и то, которое отправлено первым, может быть получено последним. Доставка сообщений UDP вовсе не гарантируется, сообщение может потеряться, и могут быть получены две копии одного и того же сообщения. Последний случай возникает, если для отправки сообщений в один адрес использовать два разных маршрута.
UDP не требует открывать соединение, и данные могут быть отправлены сразу же, как только они подготовлены. UDP не отправляет подтверждающие сообщения, поэтому данные могут быть получены или потеряны. Если при использовании UDP требуется надежная передача данных, ее следует реализовать в протоколе более высокого уровня.
UDP может использоваться для однонаправленной связи, если требуется быстрая передача, например для доставки мультимедийных данных, но главные преимущества UDP касаются широковещательной передачи и групповой рассылки.
Обычно, когда мы отправляем широковещательные или групповые сообщения, не нужно получать подтверждения из каждого узла, поскольку тогда сервер будет наводнен подтверждениями, а загрузка сети возрастет слишком сильно. Примером широковещательной передачи является служба времени. Сервер времени отправляет широковещательное сообщение, содержащее текущее время, и любой хост, если пожелает, может синхронизировать свое время с временем из широковещательного сообщения.
Дейтаграмма — это отдельный, независимый пакет данных, несущий информацию, достаточную для передачи от источника до пункта назначения, поэтому никакого дополнительного обмена между источником, адресатом и транспортной сетью не требуется.
Дейтаграмма IP состоит из 32-битных IP-адресов источника и назначения. IP-адрес назначения задает конечную точку для дейтаграммы UDP, а IP-адрес источника используется для получения информации о том, кто отправил сообщение. В пункте назначения пакеты фильтруются, и те из них, адреса источников которых не входят в допустимый набор адресов, отбрасываются без уведомления отправителя.
Классы DatagramPacket и DatagramSocket в Java поддерживают использование коммуникации UDP-сокетов на уровне приложения.
Класс DatagramSocket может выступать в роли клиента и сервера, то есть он способен получать и отправлять пакеты. Отправить пакет можно с помощью метода send(), для получения пакета используется метод receive().
По протоколу UDP данные передаются пакетами. Пакетом в этом случае UDP является объект класса DatagramPacket. Этот класс содержит в себе передаваемые данные, представленные в виде массива байт.

52.	Модель делегирования событий. События. Источники событий. Приёмники событий. Классы событий. Класс ActionEvent
Обработка любого события (нажатие кнопки, щелчок мышью и др.) состоит в связывании события с методом, его обрабатывающим. Принцип обработки событий, начиная с Java 2, базируется на модели делегирования событий. В этой модели имеется блок прослушивания события (EventListener), который ждет поступления события определенного типа от источника, после чего обрабатывает его и возвращает управление.
Обработка событий является неотъемлемой частью пользовательских интерфейсов (GUI), при этом используется модель делегирования (разделение ответственностей) событий:
●	Источник(source) создаёт объект события(event) и сообщает о нем одному или нескольким приёмникам событий(listeners). 
●	Приёмник события ожидает до тех пор, пока он не получит объект события.
●	Когда событие получено, код обработчика выполняется.
●	По его завершении, управление возвращается в основной поток выполнения программы.
Преимущество модели делегирование событий состоит в том, что логика основной программы четко отделена от логики обработки событий GUI.
 Особенности применения моделей делегирования событий:
1.	Необходимо реализовать соответствующий интерфейс в приёмнике событий, чтобы он принимать события необходимого типа.
2.	Реализовать код регистрации или снятия с регистрации приёмника как получателя уведомления о получении события.
В этой модели все слушатели, заинтересованные в событии, должны зарегистрироваться слушателями источника, то есть уведомление о создании события отправляется не всему коду, а только тому, который в нём заинтересован.
Событие представляет собой объект класса, описывающий изменение состояния источника. Можно создавать собственные события.
Источник события создаёт объект, тип которого определяет срабатываемый обработчик.
Слушатель (listener) - это объект, уведомляемый о событии. Он должен быть зарегистрирован источником событий и реализовывать методы для получения и обработки уведомлений.
Схема обработки события на пользовательском интерфейсе:
1.	Источник (source) создаёт событие (Event), тип которого зависит от действия, которое над источником выполнил юзер.
2.	Созданное событие «выбрасывается» в систему обработки событий, приводя к вызову методов слушателей (invoke listener(s)), которые зарегистрированы как участки кода «заинтересованные» в получении именно данного типа события.
3.	Каждый слушатель выполняет метод, который является реализацией интерфейса созданного типа события.
Основной класс для событий - класс EventObject, который содержит два метода getSource() и toString(). Это корневой класс, из которого должны быть получены все объекты состояния события. Все события построены со ссылкой на объект, источник , который логически считается объектом, с которым первоначально произошло рассматриваемое событие. Этот класс определен в пакете java.util. Базовый класс EventObject предназначен для описания общих свойств классов событий.
Подклассы: ConnectionEvent, HandshakeCompletedEvent, NodeChangeEvent, PreferenceChangeEvent, PropertyChangeEvent, RowSetEvent, SSLSessionBindingEvent, StatementEvent и др.
Событие ActionEvent генерируется после нажатия на кнопку, двойного щелчка мыши на элементе списка, выбора пункта меню, окончания редактирования текста элемента TextField.
В классе ActionEvent определены целочисленные константы, которые могут быть использованы для идентификации любых модификаторов, связанных с событием.
Константа ALT_MASK говорит о том, зажата ли клавиша Alt.
CTRL_MASK говорит о том, зажата ли клавиша Ctrl.
Метод getWhen() позволяет определить момент наступления события, называемый временной меткой события.

53.	Класс AdjustmentEvent. Класс ComponentEvent. Класс ContainerEvent. Класс FocusEvent
Класс AdjustmentEvent генерируется полосой прокрутки. В нём определены целочисленные константы, которые описывают направления изменения полосы прокрутки.
Класс ComponentEvent предназначен для обработки событий при изменении размеров, положения и видимости компонентов. В нём существуют константы, которые описывают видимость и скрытость компонентов, изменение размера и его перемещение.
Данное событие происходит в компоненте по четырем причинам:
1. компонент перемещается — идентификатор component_moved;
2. компонент меняет размер — идентификатор component_resized;
3. компонент убран с экрана — идентификатор component_hidden;
4. компонент появился на экране — идентификатор ccmponent_shcwn.
Класс ContainerEvent создается при добавлении компонента в контейнер или его удалении.
Данное событие происходит по двум причинам:
1. в контейнер добавлен компонент — идентификатор component_added;
2. из контейнера удален компонент — идентификатор component_removed.
Класс FocusEvent предназначен для обработки событий получения (gain) или потери фокуса.

54.	Класс InputEvent. Класс ItemEvent. Класс KeyEvent. Класс MouseEvent. Класс МouseWeelEvent
Класс InputEvent связан с любыми компонентами, которые предоставляют ввод данных.
Класс ItemEvent, который указывает, что элемент был выбран или не выбран.
Классы KeyEvent и MouseEvent предназначены для обработки событий от клавиатуры и мыши соответственно. При этом также могут использованы различные модификаторы, такие как Alt, Ctrl.
Событие типа KeyEvent генерируется при вводе с клавиатуры. Имеются три типа клавиатурных событий, обозначаемых следующими целочисленными константами:
●	KEY_PRESSED
●	КЕУ_RELEASED
●	КЕУ_TYPED
События первых двух типов наступают при нажатии и отпускании клавиши на клавиатуре, а событие третьего типа - при вводе символа. Следует, однако, иметь в виду, что нажатие не всех клавиш приводит к вводу символа с клавиатуры. Так, при нажатии клавиши <Shift> символ не вводится.
Событие типа MouseEvent генерируется мышью и могут быть связаны с нажатием одной из кнопок (левой, правой или колесиком), захватом элементов (MOUSE_DRAGGED), с входом указателя мыши в элемент и выходом из него.
MouseWeelEvent инкапсулирует событие, связанное только с прокруткой колёсика мыши и могут относится к прокрутке на один экран (один блок) и с прокруткой на одну строку (юнит). В классе MouseWheelEvent определяются целочисленные константы, перечисленные ниже:
●	WHEEL_BLOCK_SCROLL - произошло событие прокрутки содержимого на страницу вверх или вниз
●	WHEEL_UNIT_SCROLL - произошло событие прокрутки содержимого на строку вверх или вниз

55.	Класс TextEvent. Класс WindowEvent. Источники событий
Класс TextEvent описывает текстовые события, но не содержит символы, которые находятся в данный момент в текстовом компоненте. Для получения текста при создании экземпляра TextEvent, необходимо использовать методы извлечения текста из текстового компонента. 
Событие TextEvent происходит только по одной причине — изменению текста — и отмечается идентификатором TEXT_VALUE_CHANGED.
Класс WindowEvent описывает несколько типов оконных событий, которые представлены константами, например, WINDOW_CLOSED, WINDOW_CLOSING (пользователь запросил закрытие окна), WINDOW_DEICONIFIED (окошко развёрнуто), WINDOW_GAINED_FOCUS (окно получило фокус ввода).
Источниками событий (Event Source) могут быть только интерактивные элементы, те, которые предполагают взаимодействие с пользователем.
Каждый источник должен предоставлять метод регистрации слушателей и метод удаления слушателей.
При наступлении события его источник вызывает метод, который определен в приемнике события и передает ответ события в качестве аргумента.
Схема обработки события на пользовательском интерфейсе:
1.	Источник (source) создаёт событие (Event), тип которого зависит от действия, которое над источником выполнил юзер.
2.	Созданное событие «выбрасывается» в систему обработки событий, приводя к вызову методов слушателей (invoke listener(s)), которые зарегистрированы как участки кода «заинтересованные» в получении именно данного типа события.
3.	Каждый слушатель выполняет метод, который является реализацией интерфейса созданного типа события.

56.	Интерфейсы приемников событий. Интерфейс ActionListener. Интерфейс ComponentListener. Интepфeйc ContainerListener
В пакете java.awt.event определены интерфейсы слушателей для каждого из определенных в нем типов событий (например, для событий MouseEvent определено два интерфейса слушателей: MouseListener и MouseMotionListener). Все интерфейсы слушателей событий являются расширениями интерфейса java.util.EventListener. В этом интерфейсе не определяется ни один из методов, но он играет роль базового интерфейса, в котором однозначно определены все слушатели событий как таковые.Т.е. слушатель наследуется от интерфейса EventListener и предназначен для обработки определенного типа событий. При этом Listener содержит один или несколько методов, которые принимают объект события в качестве единственного параметра и вызываются в определенных ситуациях.
Интерфейс слушателя событий Listener может включать несколько методов. Например, класс событий, подобный MouseEvent, описывает несколько событий, связанных с мышью, таких как события нажатия и отпускания кнопки мыши. Эти события вызывают различные методы соответствующего слушателя.

57.  Интерфейс FocusListener. Интерфейс ItemListener. Интерфейс KeyListener. Интepфeйc MouseListener
Обработка событий является неотъемлемой части пользовательского интерфейсов(GUI). При этом используется модель делегирования событий: источник(source) создает объект события(event) и сообщает о нем одному или нескольким приёмникам событий(listerners). Приемник события ожидает до тех пор пока он не получит объект событий, когда событие получено, код обработчика выполняется по его завершению управление возвращается в основной поток выполнения программ.
 	Для обработки событий фокуса при написании Java приложений необходимо использовать FocusListener
 public class CustomListener implements FocusListener {
          public void focusGained(FocusEvent e) {
               eventLabel.setText("Button 2 — focusGained()");
          }
          public void focusLost(FocusEvent e) {
               eventLabel.setText("Button 2 — focusLost()");
          }
 ----------------------
public interface ItemListener extends EventListener

class CustomItemListener implements ItemListener {
      public void itemStateChanged(ItemEvent e) {
         statusLabel.setText(((JCheckBox)e.getItem()).getText()
            +" Checkbox: " + (e.getStateChange()==1?"checked":"unchecked"));
      }   
 
Интерфейс слушателя для получения событий элемента. Класс, который заинтересован в обработке события элемента, реализует этот интерфейс. Затем объект, созданный с помощью этого класса, регистрируется в компоненте с помощью метода компонента addItemListener . Когда происходит событие выбора элемента, itemStateChanged метод itemStateChanged объекта прослушивателя .
 
Интерфейс, который нужно реализовать для обработки клавиш был упомянут выше – это КeyListener из пакета java.awt.event. KeyListener имеет три метода: keyTyped, keyPressed и keyReleased.
 
 
 
 
 
 	textField.addKeyListener(new KeyAdapter()
    public void keyPressed(KeyEvent e) {
         
    }    
});
public interface MouseListener
extends EventListener
Интерфейс слушателя для того, чтобы получить "интересные" события от нажатия мыши (нажатие, выпуск, щелчок, входит, и выход) на компоненте. (Отслеживать перемещения мыши и мышь перетаскивает, используйте MouseMotionListener.)

58.  Интepфeйc MousemotionListener. Интepфeйc MousewheelListener. Интерфейс TextListener. Интерфейс WindowFocusListener
public interface MouseMotionListener
extends EventListener
Интерфейс слушателя для того, чтобы получить события движения мыши на компоненте. (Для щелчков и других событий от нажатия мыши, используйте MouseListener.)
Класс, который интересуется обработкой события движения мыши любой реализации этот интерфейс (и все методы это содержит) или расширяет краткий обзор MouseMotionAdapter класс (переопределяющий только методы интереса).
Объект слушателя, создаваемый из того класса, тогда регистрируется в компоненте, используя компонент addMouseMotionListener метод. Событие движения мыши сгенерировано, когда мышь перемещается или перетаскивается. (Много таких событий будут сгенерированы). Когда событие движения мыши имеет место, соответствующий метод в объекте слушателя вызывается, и MouseEvent передается к этому.
pablic interface MouseWheelListener extends EventListener
Интерфейс слушателя для получения событий колесика мыши на компоненте. (Для щелчков и других событий мыши используйте MouseListener . Для перемещения мыши и перетаскивания используйте MouseMotionListener .)
Класс,заинтересованный в обработке события колеса мыши,реализует этот интерфейс (и все методы,которые он содержит).
Затем объект слушателя, созданный из этого класса, регистрируется в компоненте с помощью метода компонента addMouseWheelListener . Событие колеса мыши генерируется, когда колесо мыши вращается. Когда происходит событие колеса мыши, mouseWheelMoved метод mouseWheelMoved этого объекта .
public interface TextListener extends EventListener
Интерфейс слушателя для того, чтобы получить текстовые события. class, который интересуется обработкой текстового события, реализует этот интерфейс. Объект, создаваемый с тем, что class тогда регистрируется в компоненте, используя компонент addTextListener метод. Когда текст компонента изменяется, объект слушателя textValueChanged метод вызывается.
public interface WindowFocusListener extends EventListener
Интерфейс слушателя для того, чтобы получить WindowEvents, включая WINDOW_GAINED_FOCUS и WINDOW_LOST_FOCUS события. Класс, который интересуется обработкой a WindowEvent любой реализации этот интерфейс (и все методы это содержит) или расширяет краткий обзор WindowAdapter класс (переопределяющий только методы интереса). Объект слушателя, создаваемый из того класса, тогда регистрируется в a Window использование Window's addWindowFocusListener метод. Когда Window's состояние изменяется на основании этого открываемый, закрытый, активированный, деактивированный, представленный в виде значка, или deiconified, или фокусом, передаваемым в или из Window, соответствующий метод в объекте слушателя вызывается, и WindowEvent передается к этому.
59.  Интерфейс WindowListener. Применение модели делегирования событий. Обработка событий от мыши. Обработка событий от клавиатуры. Классы адаптеров
public interface WindowListener
extends EventListener
Интерфейс слушателя для того, чтобы получить события окна. Класс, который интересуется обработкой события окна любой реализации этот интерфейс (и все методы это содержит) или расширяет краткий обзор WindowAdapter класс (переопределяющий только методы интереса). Объект слушателя, создаваемый из того класса, тогда регистрируется в Окне, используя окно addWindowListener метод. Когда изменения состояния окна на основании того, чтобы быть открытым, закрытый, активированный или деактивированный, представленный в виде значка или deiconified, соответствующий метод в объекте слушателя вызывается, и WindowEvent передается к этому.
 
Модель событий, применяемая в Java 1.1, подходит для использования в AWT и в Swing. В этой модели каждое событие - это класс, наследуемый от класса java.util.EventObject. Все AWT события наследуются от класса java.awt.AWTEvent. Для удобства различные типы событий AWT помещены в отдельный пакет java.awt.event.
Чтобы обработать события от мыши, следует реализовать интерфейсы MouseListener и MouseMotionListener.
public class MouseEvents extends Applet implements MouseListener, MouseMotionListener {
// обработать событие от щелчка кнопкой мыши
		public void mouseClicked(MouseEvent me) {
			// сохранить координаты
			mouseX = 0;
			mouseY = 10;
			msg = "Mouse clicked."; // Произведен щелчок кнопкой мыши
			repaint();
		}
Клавиатура
interface KeyListener {
    //клавиша нажата, но не отпущена
    public void keyPressed(KeyEvent event);
 
    //клавиша отпущена
    public void keyReleased(KeyEvent event);
 
    //клавиша нажата и отпущена
    public void keyTyped(KeyEvent event);
}
 
       
Классы адаптеры
Например, класс MouseMotionAdapter имеет два метода:
mouseDragged() и mouseMoved(). Сигнатуры этих пустых методов точно такие же, как в интерфейсе MouseMotionListener. Если существует заинтересованность только в событиях перетаскивания мыши, то можно просто расширить адаптер MouseMotionAdapter и переопределить метод mouseDragged() в своем классе. Событие же перемещения мыши обрабатывала бы реализация метода mouseMoved(), которую можно оставить пустой.

Topic 10. Проектирование и разработка приложений в архитектуре клиент сервер с организацией взаимодействия с базой данных
60.  Структура JDBC. Типы драйверов JDBC. Типичные примеры применения JDBC
JDBC – Java DataBase Connectivity – соединение с базами данных на Java. Это стандарт взаимодействия с БД. Его интерфейс поставляется в стандартной JDK в виде пакета java.sql. Какой бы библиотекой для работы с базой данных вы ни пользовались, в ее основе почти всегда лежит низкоуровневый JDBC.
JDBC-драйвер – реализация JDBC для определенной базы данных. В приложении может быть зарегистрировано несколько разных драйверов. При соединении к базе, нужный выбирается исходя из URL соединения. Например, для jdbc:mysql://localhost:3306/db_name будет использован MySQL JDBC драйвер (при наличии). Драйверы делятся на 4 типа:
Тип 1 – JDBC-ODBC мост. Делегирует работу с базой установленному в системе ODBC-драйверу. Платформозависимый. Не поддерживается с Java 8.
Тип 2 – Native API. Делегирует работу с базой библиотеке, установленной в системе. Платформозависимый. Библиотеки в отличие от ODBC специфичны для конкретной базы, поэтому такой драйвер обычно работает быстрее.
Тип 3 – драйвер сетевого протокола. Работает с промежуточным слоем (JavaEE сервером приложений), который транслирует запросы в сетевой протокол, с которым работает конкретная БД. Такой драйвер полностью реализован на Java.
Тип 4 – драйвер протокола БД/тонкий драйвер. Полная реализация протокола взаимодействия с базой данных. Отличается от типа 3 тем, что здесь логика протокола находится не на внешнем промежуточном слое, а прямо в самом драйвере
Типичные примеры использования JDBC.
Согласно традиционной модели клиент/сервер, графический пользовательский интерфейс реализуется на стороне клиента, а база данных располагается на стороне сервера. В этом случае драйвер JDBC находится на стороне клиента.
Однако современная тенденция развития программного обеспечения заключается в переходе от архитектуры клиент/сервер к “трехуровневой модели” или даже более со вершенной “n уровневой модели”. В трехуровневой модели клиент не формирует обращений к базе данных. Вместо этого он обращается к срествам промежуточного уровня на сервере, который, в свою очередь, выполняет запросы к базе данных. Трехуровневая модель имеет два преимущества. Она отделяет визуальное представление (на компьютере клиенте) от бизнес логики (промежуточный уровень) и данных (в базе данных). Таким образом, становится возможным доступ к тем же данным и тем же бизнес правилам посредством клиентов различных типов, например Java приложений, аплетов или Web форм.
Взаимодействие между клиентом и промежуточным уровнем может быть реализовано на основе протокола HTTP (при использовании Web браузера в качестве клиента), средств RMI (при использовании приложений или аплетов) или с помощью какого либо другого механизма. JDBC используется для управления взаимодействием между промежуточным уровнем и базой данных. Нужно иметь в виду, что у этой модели существует множество вариантов.

61.  Язык SQL. Конфигурирование JDBC. URL баз данных. Архивные JАR-файлы драйверов
SQL — это язык программирования, предназначенный для работы с наборами фактов и отношениями между ними  в реляционных базах данных. В программах управления реляционными базами данных, таких как Microsoft Office Access, язык SQL используется для работы с данными. В отличие от многих языков программирования, SQL удобочитаем и понятен даже новичкам
Например, простая инструкция SQL, извлекающая список фамилий контактов с именем Mary, может выглядеть следующим образом:
SELECT Last_Name
FROM Contacts
WHERE First_Name = 'Mary';
Если вы определили в вашем агенте источник данных JDBC, то в агент автоматически добавляются следующие обязательные общие поля конфигурации:
Тип базы данных JDBC: Тип базы данных, с которой устанавливается соединение: IBM® DB2, Microsoft SQL Server или Oracle Database Server.
Имя пользователя JDBC
Пароль JDBC
Базовые пути
Путь классов
Каталоги JAR
Также необходимо задать URL: jdbc:идентификатор://Сервер:порт/база_данных

62.  Запуск базы данных. Регистрация класса драйвера. Подключение к базе данных
Для запуска MySQL-сервера в системах Windows 95/98/ME необходимо выполнить файл mysqld.exe. Сервер запускается как безоконный фоновый процесс. При этом он остается в памяти и обрабатывает запросы от клиентских приложений. Если сервер не был остановлен корректно, при последующем запуске в файле mysql.
Первым шагом в использовании JDBC для операций с базой данных является регистрация драйвера (конечно, сначала нужно импортировать JAR).
Существует много способов зарегистрировать драйвер. Первым шагом должно быть получение правильного имени драйвера и формата URL.
 
Регистрация  требуется перед созданием соединения через диспетчер драйверов
Есть три формы регистрации 
    Class.forName("com.mysql.jdbc.Driver");
    DriverManager.registerDriver(new com.mysql.jdbc.Driver());
    System.setProperty("jdbc.drivers","com.mysql.jdbc.Driver");

Для подключения к базе данных необходимо создать объект java.sql.Connection. Для его создаия применяется метод:

Connection DriverManager.getConnection(url, username, password)
Метод DriverManager.getConnection в качестве параметров принимает адрес источника данных, логин и пароль. В качестве логина и пароля передаются логин и пароль от сервера MySQL. Адрес локальной базы данных MySQL указывается в следующем формате: jdbc:mysql://localhost/название_базы данных
Пример создания подключения к созданной выше локальной базе данных store:
Connection connection = DriverManager.getConnection("jdbc:mysql://localhost/store", "root", "password");

63.  Работа с операторами JDBC. Выполнение команд SQL. Управление соединениями, ко- мандами и результирующими наборами
Взаимодействовать с БД мы можем с помощью трёх интерфейсов, которые реализуются каждым драйвером:
Statement - этот интерфейс используется для доступа к БД для общих целей. Он крайне полезен, когда мы используем статические SQL – выражения во время работы программы. Этот интерфейс не принимает никаких параметров.
boolean execute(String SQL) - позволяет вам выполнить Statement, когда неизвестно заранее, является SQL-строка запросом или обновлением. Метод возвращает true, если команда создала результирующий набор.
int executeUpdate(String SQL) используется для выполнения обновлений. Он возвращает количество обновленных строк. Для выполнения операторов INSERT, UPDATE или DELETE.
ResultSet executeQuery(String SQL) - используется для выполнения запросов (SELECT). Он возвращает для обработки результирующий набор.
PreparedStatement - этот интерфейс может принимать параметры во время работы программы.
 
Особенностью SQL-выражений в PreparedStatement является то, что они могут иметь параметры. Параметризованное выражение содержит знаки вопроса в своем тексте. Например:
SELECT name FROM persons WHERE age=?
Перед выполнением запроса значение каждого вопросительного знака явно устанавливается методами setXxx()‏, например:
ps.setInt(1, 30);
CallableStatement - этот интерфейс становится полезным в случае, когда мы хотим получить доступ к различным процедурам БД. Он также может принимать параметры во время работы программы
64.  Анализ исключений SQL. Заполнение базы данных. Выполнение запросов
При использовании Microsoft JDBC Driver для SQL Server все состояния ошибок в базе данных возвращаются приложениям Java в виде исключений при помощи класса SQLServerException. Приведенные далее методы класса SQLServerException унаследованы от классов java.sql.SQLException и java.lang.Throwable. Их можно использовать для возвращения конкретной информации о возникшей ошибке SQL Server.
getSQLState() возвращает стандартный код состояния исключения X/Open или SQL99.
getErrorCode() возвращает специфический номер ошибки базы данных.
getMessage() возвращает полный текст исключения. В тексте сообщения об ошибке описывается проблема и зачастую содержатся заполнители для информации, такие как имена объектов, которые вставляются в сообщение об ошибке во время отображения.
getNextException() возвращает следующий объект SQLServerException или значение NULL, если нет других объектов исключений для возвращения.
getSQLServerError() возвращает объект SQLServerError с подробными сведениями об исключении, полученными от SQL Server. Если ошибок не было, этот метод возвращает значение NULL.
Следующие методы класса SQLServerError можно применить для получения дополнительных сведений об ошибке, созданной на сервере.
SQLServerError.getErrorMessage() возвращает сообщение об ошибке, которое вернул сервер.
SQLServerError.getErrorNumber() возвращает номер, который обозначает тип ошибки.
SQLServerError.getErrorState() возвращает числовой код ошибки, полученный из SQL Server, который обозначает ошибку, предупреждение или сообщение "данные не найдены".
Для добавления, редактирования и удаления данных мы можем ипользовать метод executeUpdate. С помощью результата метода мы можем проконтроллировать, сколько строк было добавлено, изменено или удалено.
Пример:
 Statement statement = conn.createStatement();
int rows = statement.executeUpdate("INSERT Products(ProductName, Price) VALUES ('iPhone X', 76000), ('Galaxy S9', 45000), ('Nokia 9', 36000)");
executeUpdate: выполняет такие команды, как INSERT, UPDATE, DELETE, CREATE TABLE, DROP TABLE. В качестве результата возвращает количество строк, затронутых операцией (например, количество добавленных, измененных или удаленных строк), или 0, если ни одна строка не затронута операцией или если команда не изменяет содержимое таблицы (например, команда создания новой таблицы)
 
executeQuery: выполняет команду SELECT. Возвращает объект ResultSet, который содержит результаты запроса.
execute(): выполняет любые команды и возвращает значение boolean: true - если команда возвращает набор строк (SELECT), иначе возвращается false.

65.  Синтаксис переходов в SQL. Множественные результаты. Наборы строк
Синтаксис "перехода"(escape syntax) поддерживает средства, которые обычно поддерживаются базами данных, но в разных вариантах, в зависимости от конкретного синтаксиса базы данных. Драйвер JDBC отвечает за преобразование синтаксиса перехода в синтаксис конкретной базы данных.
Переходы предусмотрены для следующих средств:
литералы времени и даты;
вызов скалярных функций;
вызов хранимых процедур;
внешние соединения;
символ перехода в операциях LIKE.
Запрос может вернуть множественные результаты. Это может произойти при выполнении хранимой процедуры или в базах данных, которые позволяют также выполнение множества операторов SELECT в одном запросе. Ниже показано, как можно получить все множественные наборы:
Используйте метод execute для выполнения оператора SQL.
Получите первый результат или обновите подсчет.
Повторите вызов метода getMoreResults(), чтобы перейти к следующему результирующему набору. Этот метод автоматически закрывает предыдущий результирующий набор.
Процедура завершается, когда заканчиваются результирующие наборы или обновленные подсчеты.
Методы execute и getMoreResults возвращает значение true, если следующим элементом в соединении является результирующий набор. Метод getUpdateCount возвращает значение -1, если следующим элементом в соединении не является обновление подсчета.
набор строк(row set). Интерфейс RowSet расширяет интерфейс ResultSet, но набор строк не привязан к соединению с базой данных.
Наборы строк также применяемые в случае, если требуется переместить результаты выполнения запроса на другой уровень сложного приложения или на другое устройство, например, на мобильный телефон. Переместить результирующий набор нельзя, так как он связан с соединением, кроме того, размеры структуры данных могут быть очень велики.
Ниже перечислены интерфейсы, содержащиеся в пакете javax.sql.rowset и расширяющие интерфейс RowSet.
CachedRowSet позволяет выполнять некоторые операции при отсутствии соединения.
WebRowSet представляет собой кэшируемый набор строк, который может быть сохранен в XML-файле. XML-файл может быть передан другому компоненту приложения и открыт с помощью другого объекта WebRowSet.
Интерфейсы FilteredRowSet и JoinRowSet поддерживают "легковесные" операции с наборами строк, эквивалентные SQL-командам SELECT и JOIN. Эти операции базируются только на данных, содержащихся в наборе строк, и соединение с базой не устанавливается.
JdbcRowSet представляет собой оболочку для ResultSet. Он определяет методы доступа и модифицирующие методы, превращая результирующий набор в компонент JavaBeans.
В компании Sun Microsystems предполагают, что производители баз данных предоставят эффективные реализации этих интерфейсов. К тому же существуют базовые реализации, которые позволяют использовать наборы строк даже в том случае, если в конкретной базе данных они не поддерживаются. Эти базовые реализации принадлежат пакету com.sun.rowset. Имена классов заканчиваются символам Impl, например, CachedRowSetImpl.


66.  Создание наборов строк. Метаданные. Транзакции. Программирование транзакций средствами JDBC. Расширенные типы данных SQL.
Метаданные это данные о данных. Дополнительная информация, которая может сопровождать классы, интерфейсы, методы.
Аннотации, как пример, являются формой метаданных.
Транзакция представляет собой последовательность операторов языка SQL, которая рассматривается как некоторое неделимое действие над базой данных, осмысленное с точки зрения пользователя. В то же время, это логическая единица работы системы. Транзакция реализует некоторую прикладную функцию, например, перевод денег с одного счета на другой в банковской системе.
Connection connection = ...;
// Сброс автофиксации
connection.setAutoCommit(false);
// Первая транзакция
PreparedStatement updateSales = connection.prepareStatement(
         "UPDATE COFFEES SET SALES = ? WHERE COF_NAME LIKE ?");
updateSales.setInt(1, 50);
updateSales.setString(2, "Colombian");
updateSales.executeUpdate();
 
// Вторая транзакция
PreparedStatement updateTotal = connection.prepareStatement(
        "UPDATE COFFEES SET TOTAL = TOTAL + ? WHERE COF_NAME LIKE ?");
updateTotal.setInt(1, 50);
updateTotal.setString(2, "Colombian");
updateTotal.executeUpdate();
// Завершение транзакции
connection.commit();
// Восстановление по умолчанию
connection.setAutoCommit(true);
 
Тип данных SQL	Тип данных Java
INTEGER или INT	Int
SMALLINT	Short
NUMERIC, DECIMAL или DEC	java.math.BigDecimal
FLOAT	Double
REAL	Float
DOUBLE	Double
CHARACTER или CHAR	String
VARCHAR, LONGCHAR	String
BOOLEAN	Boolean
DATE	java.sql.Date
TIME	java.sql.Time
TIMESTAMP	java.sql.TimeStamp
BLOB	java.sql.Blob
CLOB	java.sql.clob
ARRAY	java.sql.Array
ROWID	java.sql.RowId
NCHAR, NVARCHAR, LOG NVARCHAR	String
NCLOB	java.sql.NClob
SQLXML	java.sql.SQLXML
 

Topic 11. Средства Java для работы с XML-документами
67.  Структура ХМL-документа. Синтаксический анализ ХМL-документов. Проверка достоверности ХМL-документов. Древовидная и псевдособытийная модели

XML (eXtensible Markup Language — расширяемый язык разметки) —
рекомендован W3C как язык разметки, представляющий свод общих
синтаксических правил. XML предназначен для обмена структурированной
информацией с внешними системами. Формат для хранения должен быть
эффективным, оптимальным с точки зрения потребляемых ресурсов (памяти
и др.). Такой формат должен позволять быстро извлекать полностью или
частично хранящиеся в этом формате данные и быстро производить базовые
операции над этими данными.

Основная идея XML — текстовое представление информации с
помощью тегов, структурированных в виде дерева данных. Древовидная
структура хорошо описывает бизнес-объекты, конфигурацию, структуры
данных и т. п

Каждый документ начинается декларацией — строкой, указывающей
как минимум версию стандарта XML. В качестве других атрибутов могут быть
указаны кодировка символов и внешние связи.
<?xml version="1.0" encoding="UTF-8" standalone="yes" ?>. После декларации в XML-документе могут располагаться ссылки на документы, определяющие структуру текущего документа и собственно XML элементы (теги), которые могут иметь атрибуты и содержимое. Открывающий тег состоит из имени элемента, например <city>. Закрывающий тег состоит из того же имени, но перед именем добавляется символ «/», например </city>. Каждый XML-документ должен содержать только один корневой элемент (root element или document element). В примере есть два корневых элемента, один из которых пустой. В отличие от файла XML файл HTML может иметь несколько корневых элементов и не обязательно <HTML>.
<book>
<caption>C++
</book>
</caption>
Тег должен закрываться в том же теге, в котором был открыт. В данном
случае это caption. В HTML этого правила не существует. Любой
открывающий тег должен иметь закрывающий.
<book>
<system-exit>Zukov
</book>
Если тег не имеет содержимого, можно использовать конструкцию вида
<system-exit/>. В HTML есть возможность не закрывать теги, и браузер
определяет стили по открывающемуся тегу.

Существует три подхода (API) к обработке XML-документов:
— DOM (Document Object Model — объектная модель документов) —
платформенно-независимый программный интерфейс, позволяющий
программам и скриптам управлять содержимым документов HTML и XML, а
также изменять их структуру и оформление. Модель DOM не накладывает
ограничений на структуру документа. Любой документ известной структуры
с помощью DOM может быть представлен в виде дерева узлов, каждый узел
которого содержит элемент, атрибут, текстовый, графический или любой
другой объект. Узлы связаны между собой отношениями родитель-потомок.
— SAX (Simple API for XML) базируется на модели последовательной
одноразовой обработки и не создает внутренних деревьев. При прохождении
по XML вызывает соответствующие методы у классов, реализующих
интерфейсы, предоставляемые SAX-парсером.
— StAX (Streaming API for XML) не создает дерево объектов в памяти,
но, в отличие от SAX-парсера, за переход от одной вершины XML к другой
отвечает приложение, которое запускает разбор документа.
Анализаторы, которые строят древовидную модель, — это DOM анализаторы.
Анализаторы, которые генерируют квази события, — это SAX анализаторы.
Анализаторы, которые ждут команды от приложения для перехода к
следующему элементу XML — StAX-анализаторы.

Древовидная модель
Анализатор DOM представляет собой некоторый общий интерфейс для
работы со структурой документа. При разработке DOM-анализаторов
различными вендорами предполагалась возможность ковариантности кода,
однако при совместном использовании библиотек с аналогичными классами
следует следить за совместимостью и корректностью взаимодействия.
DOM строит дерево, которое представляет содержимое XML-документа
и определяет набор классов, представляющих каждый элемент в XMLдокументе (элементы, атрибуты, сущности, текст и т. д.).

Псевдособытийная модель
SAX-анализатор не строит дерево элементов по
содержимому XML-файла. Вместо этого анализатор читает файл и генерирует
квазисобытие при нахождении элемента, атрибута или текста. На первый
взгляд, такой подход менее естествен для приложения, использующего
анализатор, так как он не строит дерево, а приложение само должно
догадаться, какое дерево элементов описывается в XML-документе.
Однако нужно учитывать, для каких целей используются данные из
XML-файла. Очевидно, что нет смысла строить дерево объектов, содержащее
десятки тысяч элементов в памяти, если все, что необходимо, — просто
посчитать точное количество элементов в файле

68.  Определения типов документов. Схема ХМL-документов. Практический пример применения ХМL-документов. Валидация. DOM

Определение типа документа (DTD) предоставляет средства проверки файлов XML в соответствии с заданным набором правил. В процессе создания файла DTD можно указать правила, управляющие структурой всех связанных файлов XML.
DTD содержит объявления, определяющие элементы, атрибуты, нотации и объекты всех файлов XML, связанных с файлом DTD. Кроме того, DTD устанавливает ограничения на использование элементов, атрибутов, нотаций и объектов в связанных файлах XML.
Файл XML считается допустимым, если вместе с ним поставляется файл DTD (схема XML) и он соответствует всем объявлениям из этого файла (схемы XML).
 Схема — это просто XML-файл, содержащий правила для содержимого XML-файла данных. Файлы схем обычно имеют расширение XSD, тогда как для файлов данных XML используется расширение XML.
Схемы позволяют программам проверять данные. Они формируют структуру данных и обеспечивают их понятность создателю и другим людям. Например, если пользователь вводит недопустимые данные, например текст в поле даты, программа может предложить ему исправить их. Если данные в XML-файле соответствуют правилам в схеме, для их чтения, интерпретации и обработки можно использовать любую программу, поддерживающую XML.
Как практический пример откройте pom.xml.
XML документ с корректным синтаксисом называется "правильно сформированным" или "синтаксически верным".
"Валидный" XML документ кроме всего прочего должен соответствовать определенному типу документов.
Синтаксически верные XML документы
XML документ с корректным синтаксисом является "синтаксически верным".
Синтаксические правила были описаны в предыдущих главах:
	XML документ должен иметь корневой элемент
	XML элемент должен иметь закрывающий тег
	XML теги регистрозависимы
	XML элементы должны соблюдать последовательность вложенности
	Значения XML атрибутов должны заключаться в кавычки
Объектная модель документа (DOM) определяет стандартный способ доступа к элементам документа и манипулирования ими.
XML DOM
XML DOM определяет стандартный способ доступа к элементам XML документа и манипулирования ими.
XML DOM представляет XML документ в виде древовидной структуры.
При помощи дерева DOM можно получить доступ ко всем элементам документа. Можно изменять и удалять содержимое (текст и атрибуты) элементов, создавать новые элементы. Элементы, их текст и атрибуты формируют, так называемые, узлы DOM.
 
 

69.  Использование пространств имен. Потоковые синтаксические анализаторы. Применение SАХ-анализатора
SAX (простой API для XML) – это анализатор на основе событий для документов XML. В отличие от парсера DOM, парсер SAX не создает дерева разбора. SAX – это потоковый интерфейс для XML, который означает, что приложения, использующие SAX, получают уведомления о событиях, когда XML-документ обрабатывает элемент и атрибут, в одно и то же время в последовательном порядке, начиная с верхней части документа и заканчивая закрытием Корень элемент.
•	Читает XML-документ сверху вниз, распознавая токены, которые составляют правильно сформированный XML-документ.
•	Токены обрабатываются в том же порядке, в котором они появляются в документе.
•	Сообщает прикладной программе о природе токенов, с которыми анализатор сталкивался по мере их появления.
•	Прикладная программа предоставляет обработчик «события», который должен быть зарегистрирован парсером.
•	Когда токены идентифицированы, методы обратного вызова в обработчике вызываются с соответствующей информацией.
Читает XML-документ сверху вниз, распознавая токены, которые составляют правильно сформированный XML-документ.
Токены обрабатываются в том же порядке, в котором они появляются в документе.
Сообщает прикладной программе о природе токенов, с которыми анализатор сталкивался по мере их появления.
Прикладная программа предоставляет обработчик «события», который должен быть зарегистрирован парсером.
Когда токены идентифицированы, методы обратного вызова в обработчике вызываются с соответствующей информацией.
Вы должны использовать парсер SAX, когда –
•	Вы можете обрабатывать XML-документ линейно сверху вниз.
•	Документ не является глубоко вложенным.
•	Вы обрабатываете очень большой XML-документ, дерево DOM которого будет занимать слишком много памяти. Типичные реализации DOM используют десять байтов памяти для представления одного байта XML.
•	Проблема, которая должна быть решена, включает в себя только часть XML-документа.
•	Данные становятся доступными, как только они видятся синтаксическим анализатором, поэтому SAX хорошо работает для XML-документа, который поступает через поток.
Вы можете обрабатывать XML-документ линейно сверху вниз.
Документ не является глубоко вложенным.
Вы обрабатываете очень большой XML-документ, дерево DOM которого будет занимать слишком много памяти. Типичные реализации DOM используют десять байтов памяти для представления одного байта XML.
Проблема, которая должна быть решена, включает в себя только часть XML-документа.
Данные становятся доступными, как только они видятся синтаксическим анализатором, поэтому SAX хорошо работает для XML-документа, который поступает через поток.
Недостатки SAX
•	У нас нет произвольного доступа к документу XML, так как он обрабатывается только для пересылки.
•	Если вам нужно отслеживать данные, которые анализатор видел, или изменять порядок элементов, вы должны написать код и сохранить данные самостоятельно.
У нас нет произвольного доступа к документу XML, так как он обрабатывается только для пересылки.
Если вам нужно отслеживать данные, которые анализатор видел, или изменять порядок элементов, вы должны написать код и сохранить данные самостоятельно.
Интерфейс ContentHandler
Этот интерфейс указывает методы обратного вызова, которые использует синтаксический анализатор SAX для уведомления прикладной программы о компонентах документа XML, которые он видел.
•	void startDocument () – вызывается в начале документа.
•	void endDocument () – Вызывается в конце документа.
•	void startElement (String uri, String localName, String qName, Attributes atts) – Вызывается в начале элемента.
•	void endElement (String uri, String localName, String qName) – Вызывается в конце элемента.
•	Пустые символы (char [] ch, int start, int length) – Вызывается, когда встречаются символьные данные.
•	void ignorableWhitespace (char [] ch, int start, int length) – Вызывается, когда присутствует DTD и встречаются игнорируемые пробелы.
•	void processingInstruction (String target, String data) – Вызывается при распознавании инструкции обработки.
•	void setDocumentLocator (Locator locator)) – Предоставляет локатор, который можно использовать для определения позиций в документе.
•	void skippedEntity (String name) – Вызывается, когда встречается неразрешенная сущность.
•	void startPrefixMapping (String prefix, String uri) – Вызывается, когда определяется новое сопоставление пространства имен.
•	void endPrefixMapping (String prefix) – вызывается, когда определение пространства имен заканчивает свою область.
void startDocument () – вызывается в начале документа.
void endDocument () – Вызывается в конце документа.
void startElement (String uri, String localName, String qName, Attributes atts) – Вызывается в начале элемента.
void endElement (String uri, String localName, String qName) – Вызывается в конце элемента.
Пустые символы (char [] ch, int start, int length) – Вызывается, когда встречаются символьные данные.
void ignorableWhitespace (char [] ch, int start, int length) – Вызывается, когда присутствует DTD и встречаются игнорируемые пробелы.
void processingInstruction (String target, String data) – Вызывается при распознавании инструкции обработки.
void setDocumentLocator (Locator locator)) – Предоставляет локатор, который можно использовать для определения позиций в документе.
void skippedEntity (String name) – Вызывается, когда встречается неразрешенная сущность.
void startPrefixMapping (String prefix, String uri) – Вызывается, когда определяется новое сопоставление пространства имен.
void endPrefixMapping (String prefix) – вызывается, когда определение пространства имен заканчивает свою область.

70.  Формирование   ХМL-документов.   ХМL-документы   без   пространств   имен.   ХМL- документы с пространствами имен
Простейший XML- документ может выглядеть так, как это показано в Примере 1
Пример 1
<?xml version="1.0"?>
<list_of_items>
<item id="1"><first/>Первый</item>
<item id="2">Второй <sub_item>подпункт 1</sub_item></item>
<item id="3">Третий</item>
<item id="4"><last/>Последний</item>
</list_of_items>
Тело документа XML состоит из элементов разметки (markup) и непосредственно содержимого документа - данных (content). XML - тэги предназначены для определения элементов документа, их атрибутов и других конструкций языка. Более подробно о типах применяемой в документах разметки мы поговорим чуть позже.
Любой XML-документ должен всегда начинаться с инструкции , внутри которой также можно задавать номер версии языка, номер кодовой страницы и другие параметры, необходимые программе-анализатору в процессе разбора документа.
Если XML- документ не нарушает приведенные правила, то он называется формально-правильным и все анализаторы, предназначенные для разбора XML- документов, смогут работать с ним корректно.
Однако кроме проверки на формальное соответствие грамматике языка, в документе могут присутствовать средства контроля над содержанием документа, за соблюдением правил, определяющих необходимые соотношений между элементами и формирующих структуру документа. Например, следующий текст, являясь вполне правильным XML- документом, будет абсолютно бессмысленным:
<country><title>Russia</title><city><title>Novosibirsk</country>
</title></city>

Для того, чтобы обеспечить проверку корректности XML- документов, необходимо использовать анализаторы, производящие такую проверку и называемые верифицирующими.
На сегодняшний день существует два способа контроля правильности XML- документа: DTD - определения (Document Type Definition) и схемы данных (Semantic Schema). Более подробно об использовании DTD и схемах будет описано в следующих разделах. В отличии от SGML, определение DTD- правил в XML не является необходимостью, и это обстоятельство позволяет нам создавать любые XML- документы, не ломая пока голову над весьма непростым синтаксисом DTD.
Элементы данных
Элемент - это структурная единица XML- документа. Заключая слово rose в в тэги , мы определяем непустой элемент, называемый , содержимым которого является rose. В общем случае в качестве содержимого элементов могут выступать как просто какой-то текст, так и другие, вложенные, элементы документа, секции CDATA, инструкции по обработке, комментарии, - т.е. практически любые части XML- документа.
Любой непустой элемент должен состоять из начального, конечного тэгов и данных, между ними заключенных. Например, следующие фрагменты будут являться элементами:
<flower>rose</flower>
<city>Novosibirsk</city>

а эти - нет:
<rose>
<flower>
rose

Набором всех элементов, содержащихся в документе, задается его структура и определяются все иерархическое соотношения. Плоская модель данных превращается с использованием элементов в сложную иерархическую систему со множеством возможных связей между элементами. Например, в следующем примере мы описываем месторасположение Новосибирских университетов (указываем, что Новосибирский Университет расположен в городе Новосибирске, который, в свою очередь, находится в России), используя для этого вложенность элементов XML :
<country id="Russia">
<cities-list>
<city>
<title>Новосибирск</title>
<universities-list>
<university id="1">
<title>Сибирский Государственный Университет Телекоммуникаций и Информатики</title>
<address URL="www.neic.nsk.su"/>
</university>  
<university id="2">
<title>Новосибирский Государственный Университет</title>
<address URL="www.nsu.ru"/>
</university>  
</universities-list>
</city>
<city>
<title>Москва</title>
<universities-list>
<university id="1">
<title>Московский Государственный Университет</title>
<address URL="www.msu.ru"/>
</university>  
</universities-list>
</city>
</cities-list>
</country>

Производя в последствии поиск в этом документе, программа клиента будет опираться на информацию, заложенную в его структуру - используя элементы документа. Т.е. если, например, требуется найти нужный университет в нужном городе, используя приведенный фрагмент документа, то необходимо будет просмотреть содержимое конкретного элемента <university>, находящегося внутри конкретного элемента <city>. Поиск при этом, естественно, будет гораздо более эффективен, чем нахождение нужной последовательности по всему документу.
В XML документе, как правило, определяется хотя бы один элемент, называемый корневым и с него программы-анализаторы начинают просмотр документа. В приведенном примере этим элементом является <country>
В некоторых случаях тэги могут изменять и уточнять семантику тех или иных фрагментов документа, по разному определяя одну и ту же информацию и тем самым предоставляя приложению-анализатору этого документа сведения о контексте использования описываемых данных. Например, прочитав фрагмент <river>Lena</river> мы можем догадаться, что речь в этой части документа идет о реке, а вот во фрагменте <name>Lena</name> - о имени.
В случае, если элемент не имеет содержимого, т.е. нет данных, которые он должен определять, он называется пустым. Примером пустых элементов в HTML могут служить такие тэги HTML, как <br>, <hr>, <img>;. Необходимо только помнить, что начальный и конечные тэги пустого элемента как бы объединяется в один, и надо обязательно ставить косую черту перед закрывающей угловой скобкой (например, <empty/>;)
Комментарии
Комментариями является любая область данных, заключенная между последовательностями символов Комментарии пропускаются анализатором и поэтому при разборе структуры документа в качестве значащей информации не рассматриваются.
Атрибуты
Если при определении элементов необходимо задать какие-либо параметры, уточняющие его характеристики, то имеется возможность использовать атрибуты эдлемента. Атрибут - это пара "название" = "значение", которую надо задавать при определении элемента в начальном тэге. Пример:
<color RGB="true">#ff08ff</color>
<color RGB="false">white</color>

или
<author id=0>Ivan Petrov</autho>

Примером использования атрибутов в HTML является описание элемента <font>:

<font color="white" name="Arial">Black</font>

Cпециальные символы
Для того, чтобы включить в документ символ, используемый для определения каких-либо конструкций языка (например, символ угловой скобки) и не вызвать при этом ошибок в процессе разбора такого документа, нужно использовать его специальный символьный либо числовой идентификатор. Например, < , > " или $(десятичная форма записи), &#x1a (шестнадцатеричная) и т.д. Строковые обозначения спецсиволов могут определяться в XML документе при помощи компонентов (entity).
Директивы анализатора
Инструкции, предназначенные для анализаторов языка, описываются в XML документе при помощи специальных тэгов - ;. Программа клиента использует эти инструкции для управления процессом разбора документа. Наиболее часто инструкции используются при определении типа документа (например, ) или создании пространства имен.
CDATA
Чтобы задать область документа, которую при разборе анализатор будет рассматривать как простой текст, игнорируя любые инструкции и специальные символы, но, в отличии от комментариев, иметь возможность использовать их в приложении, необходимо использовать тэги . Внутри этого блока можно помещать любую информацию, которая может понадобится программе- клиенту для выполнения каких-либо действий (в область CDATA, можно помещать, например, инструкции JavaScript). Естественно, надо следить за тем, чтобы в области, ограниченной этими тэгами не было последовательности символов.

Пространство имен для элемента объявляется с помощью атрибута xmlns::
xmlns:<name>=<"uri">
где <name> — это префикс пространства имен, а <"uri"> — это URI, который определяет это пространство имен. После объявления префикса его можно использовать для уточнения имен элементов и атрибутов в XML-документе и связывания их с URI-кодом пространства имен. Так как этот префикс пространства имен используется во всем документе, он должен быть коротким.
В данном примере определяются два элемента BOOK. Первый элемент квалифицируется префиксом mybook, а второй — префиксом bb. Каждый префикс связан с разными URI-кодами пространств имен:
XML
<mybook:BOOK xmlns:mybook="http://www.contoso.com/books.dtd">  
    <bb:BOOK xmlns:bb="urn:blueyonderairlines" />
</mybook:BOOK>
Чтобы указать, что элемент принадлежит к определенному пространству имен, добавьте к нему префикс пространства имен. Например, если Author элемент принадлежит пространству mybook имен, он объявляется как <mybook:Author>.

71.  Запись ХМL-документов. Преобразование ХМL-документов языковыми средствами XSLT. Схема XSD.
Преобразование XML-данных с помощью XSLT
Расширяемые преобразования языка таблиц стилей (XSLT) API-интерфейсы могут использоваться для многих целей. Например, с достаточно интеллектуальной таблицей стилей вы можете генерировать выходные данные в формате PDF или PostScript из XML-данных. Но, как правило, XSLT используется для генерации форматированных выходных данных HTML или для создания альтернативного представления данных в формате XML.
XSD — это язык описания структуры XML документа. Его также называют XML Schema. При использовании XML Schema XML парсер может проверить не только правильность синтаксиса XML документа, но также его структуру, модель содержания и типы данных.
 
Topic 12. Технологии программирования сетевых Web-приложений (сервлеты и Java Server Pages)
72.  Понятие сервлетов. Жизненный цикл сервлета. Основные интерфейсы и классы для разработки сервлетов.

Сервлет - это класс, который расширяет функциональность класса HttpServlet и запускается внутри контейнера сервлетов.
Сервлет размещается на сервере, однако чтобы сервер мог использовать сервлет для обработки запросов, сервер должен поддерживать движок или контейнер сервлетов (servlet container/engine). Например, Apache Tomcat по сути является контейнером сервлетов, поэтому он может использовать сервлеты для обслуживания запросов.

Для обработки запроса в HttpServlet определен ряд методов, которые мы можем переопределить в классе сервлета:


•	doGet: обрабатывает запросы GET (получение данных)


•	doPost: обрабатывает запросы POST (отправка данных)


•	doPut: обрабатывает запросы PUT (отправка данных для изменения)


•	doDelete: обрабатывает запросы DELETE (удаление данных)


•	doHead: обрабатывает запросы HEAD

Каждый метод обрабатывает определенный тип запросов HTTP, и мы можем определить все эти методы.

Все методы в качестве параметра принимают два объекта: HttpServletRequest - хранит информацию о запросе и HttpServletResponse - управляет ответом на запрос.

Для каждого сервлета движок сервлетов создает только одну копию. Вне зависимости от того, сколько запросов будет отправлено сервлету, все запросы будут обрабатываться толькой одной копией сервлета. Объект сервлета создается либо при запуске движка сервлетов, либо когда сервлет получает первый запрос. Затем для каждого запроса запускается поток, который обращается к объекту сервлета.

При работе с сервлетом движок сервлетов вызывает у класса сервлета ряд методов, которые определены в родительском абстрактном классе HttpServlet.


1.	Когда движок сервлетов создает объект сервлета, у сервлета вызывается метод init().
2.	Когда к сервлету приходит запрос, движок сервлетов вызывает метод service() сервлета. А этот метод, исходя из типа запроса (GET, POST, PUT и т.д.) решает, какому методу сервлета (doGet, doPost и т.д.) обрабатывать этот запрос.
3.	Если объект сервлета долгое время не используется (к нему нет никаких запросов), или если происходит завершение работы движка сервлетов, то движок сервлетов выгружает из памяти все созданные экземпляры сервлетов. Однако до выгрузки сервлета из памяти у сервлета вызывается метод destroy().

Поскольку для обработки всех запросов создается один экземпляр сервлета, и все обращения к нему идут в отдельных потоках, то не рекомендуется в классе сервлета объявлять и использовать глобальные переменные, так как они не будут потокобезопасными.

73.  Запросы HTTP. Понятие JSP. Типы скриптовых элементов в JSP и их особенности

Java Server Pages представляет технологию, которая позволяет создавать динамические веб-страницы. По сути Java Server Page или JSP представляет собой html-код с вкраплениями кода Java. В то же время станицы jsp - это не стандартные html-страницы. Когда приходит запрос к определенной странице JSP, то сервер обрабатывает ее, генерирует из нее код html и отправляет его клиенту. В итоге пользователь после обращения к странице JSP видит в своем браузере обычную html-страницу. Как и обычные статические веб-страницы, файлы JSP необходимо размещать на веб-сервере, к которому обычные пользователи могут обращаться по протоколу http, например, набирая в адресной строке браузера нужный адрес. Однако чтобы сервер мог обрабатывать файлы JSP, он должен использовать движок JSP (JSP engine), который также называют JSP-контейнером.

Содержимое страницы JSP фактически делится на код html (а также css/javascript) и код на языке java. Для вставки кода Java на страницу JSP можно использовать пять основных элементов:


•	Выражения JSP (JSP Expression)


•	Скриплет JSP (JSP Scriplet)


•	Объявления JSP (JSP Declaration)


•	Директивы JSP (JSP Directive)


•	Комментарии JSP



1.	JSP Expression представляет выражение, заключенное между тегами <%= и %>. При обращении к JSP вычисляется значение этого выражения.
2.	JSP Scriplet представляет одну или несколько строк на языке Java. Скриплет заключается внутри следующих тегов:
<% 
    код Java
%>
3.	JSP Declaration позволяют определить метод, который мы затем можем вызывать в скриплетах или в JSP-выражениях. Определение метода помещается между тегами <%! и %>.
4.	Директивы предназначены для установки условий, которые применяются ко всей странице JSP. Наиболее используемая директива - это директива page. Например, с помощью атрибута import этой директивы мы можем импортировать пакеты или отдельные классы на страницу jsp.
Например:
<%@ page import="java.util.Data" %> - импорт нужного класса или пакета

Импорт всего пакета:
<%@ page import="java.util.*" %>

Если необходимо импортировать несколько классов и(или) пакетов, то они перечисляются через запятую:
<%@ page import="java.util.Data, java.text.*" %>
5.	Комментарии JSP добавляются с помощью тега <%-- Текст_комментария --%>:

74.  Методы передачи данных HTML-форм. Интегрирование сервлетов и JSP.
	Станицы JSP могут получать отправленные данные, например, через параметры или в виде отправленных форм, так же, как это происходит в сервлете. Для этого внутри страницы jsp доступен объект request, который позволяет получить данные посредством следующих методов:


•	getParameter(String param): возвращает значение определенного параметра, название которого передается в метод. Если указанного параметра в запросе нет, то возвращается значение null.


•	getParameterValues(String param): возвращает массив значений, который представляет определенный параметр. Если указанного параметра в запросе нет, то возвращается значение null.

Например: в форме можно явно в action указать путь к postuser.jsp. При нажатии на кнопку данные формы уходят странице postuser.jsp. Таким образом, после ввода данных и их отправке на странице index.html эти данные будут получены скриптом postuser.jsp

Есть несколько способов передачи данных из сервлета в jsp, которые заключаются в использовании определенного контекста или scope. Есть несколько контекстов для передачи данных:


•	request (контекст запроса): данные сохраняются в HttpServletRequest


•	session (контекст сессии): данные сохраняются в HttpSession


•	application (контекст приложения): данные сохраняются в ServletContext

Данные из контекста запроса доступны только в пределах текущего запроса. Данные из контекста сессии доступны только в пределах текущего сеанса. А данные из контекста приложения доступны постоянно, пока работает приложение.

Но вне зависимости от выбранного способа передача данных осуществляется с помощью метода setAttribute(name, value), где name - строковое название данных, а value - сами данные, которые могут представлять различные данные.

Наиболее распространенный способ передачи данных из сервлета в jsp представляют атрибуты запроса. То есть у объекта HttpServletRequest, который передается в сервлет, вызывается метод setAttribute(). Этот метод устанавливает атрибут, который можно получить в jsp.

Контекст приложения

Использование контекста приложения представляет применение объекта ServletContext, который можно получить в сервлете с помощью метода getServletContext():

@WebServlet("/hello")
public class HelloServlet extends HttpServlet {
  
    protected void doGet(HttpServletRequest request, HttpServletResponse response) 
            throws ServletException, IOException {
         
        ServletContext selvletContext = getServletContext();
        selvletContext.setAttribute("name", "Tom");
        selvletContext.setAttribute("age", 35);
         
        getServletContext().getRequestDispatcher("/basic.jsp").forward(request, response);
    }
}

Контекст сессии

Подобным образом можно передать данные в jsp через сессию:

@WebServlet("/hello")
public class HelloServlet extends HttpServlet {
  
    protected void doGet(HttpServletRequest request, HttpServletResponse response) 
            throws ServletException, IOException {
         
        HttpSession session = request.getSession();
        session.setAttribute("name", "Tom");
        session.setAttribute("age", 34);
         
        getServletContext().getRequestDispatcher("/basic.jsp").forward(request, response);
    }
}

=)(=



